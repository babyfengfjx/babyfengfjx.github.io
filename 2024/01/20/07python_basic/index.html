<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="python基础知识"><meta name="keywords" content="python,面向对象"><meta name="author" content="babyfengfjx"><meta name="copyright" content="babyfengfjx"><title>python基础知识 | babyfengfjx'Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"RPHOC0H5T9","apiKey":"723903e5de5899f6cc4ad96fc50931c1","indexName":"hexo_blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Python-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">Python 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">Python 定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">Python程序的执行方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E5%BC%8F"><span class="toc-number">1.2.1.</span> <span class="toc-text">交互式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%BC%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">文件式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">执行过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.</span> <span class="toc-text">解释器类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97"><span class="toc-number">2.</span> <span class="toc-text">数据基本运算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">2.1.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pycharm%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">2.1.1.</span> <span class="toc-text">pycharm常用快捷键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">2.1.2.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.3.</span> <span class="toc-text">函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">2.2.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#del-%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.3.</span> <span class="toc-text">del 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.4.</span> <span class="toc-text">核心数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E5%80%BC%E5%AF%B9%E8%B1%A1-None"><span class="toc-number">2.4.1.</span> <span class="toc-text">空值对象 None</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E5%BD%A2int"><span class="toc-number">2.4.2.</span> <span class="toc-text">整形int</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8Bfloat"><span class="toc-number">2.4.3.</span> <span class="toc-text">浮点型float</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2str"><span class="toc-number">2.4.4.</span> <span class="toc-text">字符串str</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%95%B0complex"><span class="toc-number">2.4.5.</span> <span class="toc-text">复数complex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B0%94bool"><span class="toc-number">2.4.6.</span> <span class="toc-text">布尔bool</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.5.</span> <span class="toc-text">数据类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.6.</span> <span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.6.1.</span> <span class="toc-text">算术运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BA%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.6.2.</span> <span class="toc-text">增强运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.6.3.</span> <span class="toc-text">比较运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.6.4.</span> <span class="toc-text">逻辑运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8Eand"><span class="toc-number">2.6.4.1.</span> <span class="toc-text">与and</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%96or"><span class="toc-number">2.6.4.2.</span> <span class="toc-text">或or</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E-not"><span class="toc-number">2.6.4.3.</span> <span class="toc-text">非 not</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%AD%E8%B7%AF%E8%BF%90%E7%AE%97"><span class="toc-number">2.6.4.4.</span> <span class="toc-text">短路运算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BA%AB%E4%BB%BD%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.6.5.</span> <span class="toc-text">身份运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">2.6.6.</span> <span class="toc-text">优先级</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.</span> <span class="toc-text">语句</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C"><span class="toc-number">3.1.</span> <span class="toc-text">行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pass-%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.2.</span> <span class="toc-text">pass 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.3.</span> <span class="toc-text">选择语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#If-elif-else-%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.3.1.</span> <span class="toc-text">If elif else 语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if-%E8%AF%AD%E5%8F%A5%E7%9A%84%E7%9C%9F%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.3.2.</span> <span class="toc-text">if 语句的真值表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.3.3.</span> <span class="toc-text">条件表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.4.</span> <span class="toc-text">循环语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#while%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.4.1.</span> <span class="toc-text">while语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for-%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.4.2.</span> <span class="toc-text">for 语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#range-%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.3.</span> <span class="toc-text">range 函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.5.</span> <span class="toc-text">跳转语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#break-%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.5.1.</span> <span class="toc-text">break 语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#continue-%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.5.2.</span> <span class="toc-text">continue 语句</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">容器类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.</span> <span class="toc-text">通用操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.1.1.</span> <span class="toc-text">数学运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.1.2.</span> <span class="toc-text">成员运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95index"><span class="toc-number">4.1.3.</span> <span class="toc-text">索引index</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87slice"><span class="toc-number">4.1.4.</span> <span class="toc-text">切片slice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.5.</span> <span class="toc-text">内建函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-str"><span class="toc-number">4.2.</span> <span class="toc-text">字符串 str</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">4.2.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81"><span class="toc-number">4.2.2.</span> <span class="toc-text">编码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">相关函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="toc-number">4.2.3.</span> <span class="toc-text">字面值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%BC%95%E5%92%8C%E5%8F%8C%E5%BC%95%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">单引和双引号的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%BC%95%E5%8F%B7%E4%BD%9C%E7%94%A8"><span class="toc-number">4.2.3.2.</span> <span class="toc-text">三引号作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="toc-number">4.2.3.3.</span> <span class="toc-text">转义字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">4.2.3.4.</span> <span class="toc-text">字符串格式化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E8%A1%A8-list"><span class="toc-number">4.3.</span> <span class="toc-text">列表 list</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-number">4.3.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C"><span class="toc-number">4.3.2.</span> <span class="toc-text">基础操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">4.3.3.</span> <span class="toc-text">深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8VS%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">4.3.4.</span> <span class="toc-text">列表VS字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F"><span class="toc-number">4.3.5.</span> <span class="toc-text">列表推导式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F%E5%B5%8C%E5%A5%97"><span class="toc-number">4.3.6.</span> <span class="toc-text">列表推导式嵌套</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%BB%84-tuple"><span class="toc-number">4.4.</span> <span class="toc-text">元组 tuple</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="toc-number">4.4.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C-1"><span class="toc-number">4.4.2.</span> <span class="toc-text">基础操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">4.4.3.</span> <span class="toc-text">作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E5%85%B8-dict"><span class="toc-number">4.5.</span> <span class="toc-text">字典 dict</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-3"><span class="toc-number">4.5.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C-2"><span class="toc-number">4.5.2.</span> <span class="toc-text">基础操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%E6%8E%A8%E5%AF%BC%E5%BC%8F"><span class="toc-number">4.5.3.</span> <span class="toc-text">字典推导式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E5%85%B8-VS-%E5%88%97%E8%A1%A8"><span class="toc-number">4.5.4.</span> <span class="toc-text">字典 VS 列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88-set"><span class="toc-number">4.6.</span> <span class="toc-text">集合 set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-4"><span class="toc-number">4.6.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C-3"><span class="toc-number">4.6.2.</span> <span class="toc-text">基础操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97"><span class="toc-number">4.6.3.</span> <span class="toc-text">运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%8E%A8%E5%AF%BC%E5%BC%8F"><span class="toc-number">4.6.4.</span> <span class="toc-text">集合推导式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-function"><span class="toc-number">5.</span> <span class="toc-text">函数 function</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#pycharm%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE"><span class="toc-number">5.1.</span> <span class="toc-text">pycharm相关设置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-5"><span class="toc-number">5.2.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-1"><span class="toc-number">5.3.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="toc-number">5.4.</span> <span class="toc-text">定义函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">5.5.</span> <span class="toc-text">调用函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">5.6.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%EF%BC%8F%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B%E5%9C%A8%E4%BC%A0%E5%8F%82%E6%97%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.7.</span> <span class="toc-text">可变／不可变类型在传参时的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">5.8.</span> <span class="toc-text">函数参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E5%8F%82%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8Fargument"><span class="toc-number">5.8.1.</span> <span class="toc-text">实参传递方式argument</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E7%BD%AE%E4%BC%A0%E5%8F%82"><span class="toc-number">5.8.1.1.</span> <span class="toc-text">位置传参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E4%BC%A0%E5%8F%82"><span class="toc-number">5.8.1.2.</span> <span class="toc-text">序列传参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E4%BC%A0%E5%8F%82"><span class="toc-number">5.8.1.3.</span> <span class="toc-text">关键字传参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%E5%85%B3%E9%94%AE%E5%AD%97%E4%BC%A0%E5%8F%82"><span class="toc-number">5.8.1.4.</span> <span class="toc-text">字典关键字传参</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%A2%E5%8F%82%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8Fparameter"><span class="toc-number">5.8.2.</span> <span class="toc-text">形参定义方式parameter</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0"><span class="toc-number">5.8.2.1.</span> <span class="toc-text">缺省参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E7%BD%AE%E5%BD%A2%E5%8F%82"><span class="toc-number">5.8.2.2.</span> <span class="toc-text">位置形参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%9F%E5%8F%B7%E5%85%83%E7%BB%84%E5%BD%A2%E5%8F%82"><span class="toc-number">5.8.2.3.</span> <span class="toc-text">星号元组形参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E5%85%B3%E9%94%AE%E5%AD%97%E5%BD%A2%E5%8F%82"><span class="toc-number">5.8.2.4.</span> <span class="toc-text">命名关键字形参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%98%9F%E5%8F%B7%E5%AD%97%E5%85%B8%E5%BD%A2%E5%8F%82"><span class="toc-number">5.8.2.5.</span> <span class="toc-text">双星号字典形参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%87%AA%E5%B7%A6%E8%87%B3%E5%8F%B3%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.8.2.6.</span> <span class="toc-text">参数自左至右的顺序</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9FLEGB"><span class="toc-number">6.</span> <span class="toc-text">作用域LEGB</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%90%8D%E7%9A%84%E6%9F%A5%E6%89%BE%E8%A7%84%E5%88%99"><span class="toc-number">6.1.</span> <span class="toc-text">变量名的查找规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">6.2.</span> <span class="toc-text">局部变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">6.3.</span> <span class="toc-text">全局变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#global-%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.4.</span> <span class="toc-text">global 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nonlocal-%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.5.</span> <span class="toc-text">nonlocal 语句</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-Object-Oriented"><span class="toc-number">7.</span> <span class="toc-text">面向对象 Object Oriented</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">7.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B"><span class="toc-number">7.1.1.</span> <span class="toc-text">面向过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.1.2.</span> <span class="toc-text">面向对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.2.</span> <span class="toc-text">类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">7.2.1.</span> <span class="toc-text">基础概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">7.2.2.</span> <span class="toc-text">语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%B1%BB"><span class="toc-number">7.2.2.1.</span> <span class="toc-text">定义类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1-%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">7.2.2.2.</span> <span class="toc-text">创建对象(实例化)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%88%90%E5%91%98"><span class="toc-number">7.2.3.</span> <span class="toc-text">实例成员</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F"><span class="toc-number">7.2.3.1.</span> <span class="toc-text">实例变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">7.2.3.2.</span> <span class="toc-text">实例方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%88%90%E5%91%98"><span class="toc-number">7.2.4.</span> <span class="toc-text">类成员</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F"><span class="toc-number">7.2.4.1.</span> <span class="toc-text">类变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">7.2.4.2.</span> <span class="toc-text">类方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">7.2.5.</span> <span class="toc-text">静态方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="toc-number">7.3.</span> <span class="toc-text">三大特征</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">7.3.1.</span> <span class="toc-text">封装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%A7%92%E5%BA%A6%E8%AE%B2"><span class="toc-number">7.3.1.1.</span> <span class="toc-text">数据角度讲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E8%A7%92%E5%BA%A6%E8%AE%B2"><span class="toc-number">7.3.1.2.</span> <span class="toc-text">行为角度讲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E8%A7%92%E5%BA%A6%E8%AE%B2"><span class="toc-number">7.3.1.3.</span> <span class="toc-text">设计角度讲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-number">7.3.1.4.</span> <span class="toc-text">案例:信息管理系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82"><span class="toc-number">7.3.1.5.</span> <span class="toc-text">需求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">7.3.1.6.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.3.1.7.</span> <span class="toc-text">设计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">7.3.2.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E8%A7%92%E5%BA%A6%E8%AE%B2"><span class="toc-number">7.3.2.1.</span> <span class="toc-text">语法角度讲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95"><span class="toc-number">7.3.2.2.</span> <span class="toc-text">继承方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="toc-number">7.3.2.3.</span> <span class="toc-text">内置函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%95%B0%E6%8D%AE"><span class="toc-number">7.3.2.4.</span> <span class="toc-text">继承数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-6"><span class="toc-number">7.3.2.5.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">7.3.2.6.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">7.3.2.7.</span> <span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E8%A7%92%E5%BA%A6%E8%AE%B2-1"><span class="toc-number">7.3.2.8.</span> <span class="toc-text">设计角度讲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-7"><span class="toc-number">7.3.2.9.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E6%80%A7"><span class="toc-number">7.3.2.10.</span> <span class="toc-text">适用性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">7.3.2.11.</span> <span class="toc-text">相关概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">7.3.2.12.</span> <span class="toc-text">多继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%BB%83%E4%B9%A001"><span class="toc-number">7.3.2.13.</span> <span class="toc-text">继承练习01</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%BB%83%E4%B9%A002"><span class="toc-number">7.3.2.14.</span> <span class="toc-text">继承练习02</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%BB%83%E4%B9%A003"><span class="toc-number">7.3.2.15.</span> <span class="toc-text">继承练习03</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">7.3.3.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E8%A7%92%E5%BA%A6%E8%AE%B2-2"><span class="toc-number">7.3.3.1.</span> <span class="toc-text">设计角度讲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-8"><span class="toc-number">7.3.3.2.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-2"><span class="toc-number">7.3.3.3.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E8%A7%92%E5%BA%A6%E8%AE%B2-1"><span class="toc-number">7.3.3.4.</span> <span class="toc-text">语法角度讲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%86%99"><span class="toc-number">7.3.3.5.</span> <span class="toc-text">重写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">7.3.3.6.</span> <span class="toc-text">快捷键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E5%8F%AF%E9%87%8D%E5%86%99%E5%87%BD%E6%95%B0"><span class="toc-number">7.3.3.7.</span> <span class="toc-text">内置可重写函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">7.3.3.8.</span> <span class="toc-text">转换字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">7.3.3.9.</span> <span class="toc-text">运算符重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.3.3.10.</span> <span class="toc-text">算数运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">7.3.3.11.</span> <span class="toc-text">反向算数运算符重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">7.3.3.12.</span> <span class="toc-text">复合运算符重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E9%87%8D%E8%BD%BD"><span class="toc-number">7.3.3.13.</span> <span class="toc-text">比较运算重载</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">7.4.</span> <span class="toc-text">设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80-%E9%97%AD%E5%8E%9F%E5%88%99%EF%BC%88%E7%9B%AE%E6%A0%87%E3%80%81%E6%80%BB%E7%9A%84%E6%8C%87%E5%AF%BC%E6%80%9D%E6%83%B3%EF%BC%89"><span class="toc-number">7.4.1.</span> <span class="toc-text">开-闭原则（目标、总的指导思想）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%EF%BC%88%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%89"><span class="toc-number">7.4.2.</span> <span class="toc-text">类的单一职责（一个类的定义）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%EF%BC%88%E4%BE%9D%E8%B5%96%E6%8A%BD%E8%B1%A1%EF%BC%89"><span class="toc-number">7.4.3.</span> <span class="toc-text">依赖倒置（依赖抽象）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99%EF%BC%88%E5%A4%8D%E7%94%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%89"><span class="toc-number">7.4.4.</span> <span class="toc-text">组合复用原则（复用的最佳实践）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%EF%BC%88%E7%BB%A7%E6%89%BF%E5%90%8E%E7%9A%84%E9%87%8D%E5%86%99%EF%BC%8C%E6%8C%87%E5%AF%BC%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%89"><span class="toc-number">7.4.5.</span> <span class="toc-text">里氏替换（继承后的重写，指导继承的设计）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%EF%BC%88%E7%B1%BB%E4%B8%8E%E7%B1%BB%E4%BA%A4%E4%BA%92%E7%9A%84%E5%8E%9F%E5%88%99%EF%BC%89"><span class="toc-number">7.4.6.</span> <span class="toc-text">迪米特法则（类与类交互的原则）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0"><span class="toc-number">7.4.7.</span> <span class="toc-text">综合练习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E4%BF%A1%E6%81%AF"><span class="toc-number">7.4.7.1.</span> <span class="toc-text">需求信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%9B%BE"><span class="toc-number">7.4.7.2.</span> <span class="toc-text">设计图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A0%81-1"><span class="toc-number">7.4.7.3.</span> <span class="toc-text">编码</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-number">8.</span> <span class="toc-text">程序结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97-Module"><span class="toc-number">8.1.</span> <span class="toc-text">模块 Module</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-9"><span class="toc-number">8.1.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-3"><span class="toc-number">8.1.2.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5"><span class="toc-number">8.1.3.</span> <span class="toc-text">导入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#import"><span class="toc-number">8.1.3.1.</span> <span class="toc-text">import</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#from-import"><span class="toc-number">8.1.3.2.</span> <span class="toc-text">from import</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#from-import-1"><span class="toc-number">8.1.3.3.</span> <span class="toc-text">from import \*</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8F%98%E9%87%8F"><span class="toc-number">8.1.4.</span> <span class="toc-text">模块变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">8.1.5.</span> <span class="toc-text">加载过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">8.1.6.</span> <span class="toc-text">分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85package"><span class="toc-number">8.2.</span> <span class="toc-text">包package</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-10"><span class="toc-number">8.2.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-4"><span class="toc-number">8.2.2.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5-1"><span class="toc-number">8.2.3.</span> <span class="toc-text">导入</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E5%8C%85%E5%86%85%E7%9A%84%E6%89%80%E6%9C%89%E5%AD%90%E5%8C%85%E5%92%8C%E6%A8%A1%E5%9D%97"><span class="toc-number">9.</span> <span class="toc-text">导入包内的所有子包和模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#init-py-%E6%96%87%E4%BB%B6"><span class="toc-number">9.0.1.</span> <span class="toc-text">init.py 文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#all"><span class="toc-number">9.0.1.1.</span> <span class="toc-text">all</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E9%A1%BA%E5%BA%8F"><span class="toc-number">9.0.2.</span> <span class="toc-text">搜索顺序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86Error"><span class="toc-number">10.</span> <span class="toc-text">异常处理Error</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">10.1.</span> <span class="toc-text">异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86"><span class="toc-number">10.2.</span> <span class="toc-text">处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#raise-%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.3.</span> <span class="toc-text">raise 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">10.4.</span> <span class="toc-text">自定义异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%E4%BD%BF%E7%94%A8%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%BB%83%E4%B9%A0%EF%BC%9A"><span class="toc-number">10.4.0.1.</span> <span class="toc-text">综合使用异常处理练习：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3"><span class="toc-number">11.</span> <span class="toc-text">迭代</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1iterable"><span class="toc-number">11.1.</span> <span class="toc-text">可迭代对象iterable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AF%B9%E8%B1%A1iterator"><span class="toc-number">11.2.</span> <span class="toc-text">迭代器对象iterator</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8generator"><span class="toc-number">12.</span> <span class="toc-text">生成器generator</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E5%87%BD%E6%95%B0"><span class="toc-number">12.1.</span> <span class="toc-text">生成器函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">12.2.</span> <span class="toc-text">内置生成器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%87%BD%E6%95%B0enumerate"><span class="toc-number">12.2.1.</span> <span class="toc-text">枚举函数enumerate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zip"><span class="toc-number">12.2.2.</span> <span class="toc-text">zip</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">12.3.</span> <span class="toc-text">生成器表达式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">13.</span> <span class="toc-text">函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0"><span class="toc-number">13.1.</span> <span class="toc-text">函数作为参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">13.1.1.</span> <span class="toc-text">lambda 表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-number">13.1.2.</span> <span class="toc-text">内置高阶函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">13.2.</span> <span class="toc-text">函数作为返回值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">13.2.1.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8decorator"><span class="toc-number">13.2.2.</span> <span class="toc-text">函数装饰器decorator</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://github.com/babyfengfjx/babyfengfjx.github.io/blob/main/pictures/avatar/avatar.jpg?raw=true"></div><div class="author-info__name text-center">babyfengfjx</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">25</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">30</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">16</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">babyfengfjx'Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">python基础知识</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2024-01-20</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/python/">python</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="Python-简介"><a href="#Python-简介" class="headerlink" title="Python 简介"></a>Python 简介</h1><h2 id="Python-定义"><a href="#Python-定义" class="headerlink" title="Python 定义"></a>Python 定义</h2><p><img src="/pictures/07python_basic/image-20230103160116244.png" alt="image-20230103160116244"></p>
<p>是一个免费、开源、跨平台、动态、面向对象的编程语言。</p>
<h2 id="Python程序的执行方式"><a href="#Python程序的执行方式" class="headerlink" title="Python程序的执行方式"></a>Python程序的执行方式</h2><h3 id="交互式"><a href="#交互式" class="headerlink" title="交互式"></a>交互式</h3><blockquote>
<p>在命令行输入指令，回车即可得到结果。</p>
</blockquote>
<p>打开终端》进入交互式：python3》编写代码：print(“hello world”)》离开交互式：exit()</p>
<h3 id="文件式"><a href="#文件式" class="headerlink" title="文件式"></a>文件式</h3><p>将指令编写到.py文件，可以重复运行程序：编写文件》打开终端》进入程序所在目录：cd 目录》执行程序： python3 文件名</p>
<h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p><img src="/pictures/07python_basic/image-20230103160129679.png" alt="image-20230103160129679"></p>
<p>计算机只能识别机器码(1010)，不能识别源代码(python)。</p>
<ol start="14">
<li><p>由源代码转变成机器码的过程分成两类：编译和解释。</p>
</li>
<li><p>编译：在程序运行之前，通过编译器将源代码变成机器码，例如：C语言。</p>
</li>
</ol>
<p>– 优点：运行速度快</p>
<p>– 缺点：开发效率低，不能跨平台。</p>
<ol start="16">
<li>解释：在程序运行之时，通过解释器对程序逐行翻译，然后执行。例如Javascript</li>
</ol>
<p>– 优点：开发效率高，可以跨平台；</p>
<p>– 缺点：运行速度慢。</p>
<ol start="17">
<li>python是解释型语言，但为了提高运行速度，使用了一种编译的方法。编译之后得到pyc文件，存储了字节码（特定于Python的表现形式，不是机器码）。</li>
</ol>
<blockquote>
<p>源代码 – 编译 –&gt; 字节码 – 解释 –&gt; 机器码</p>
</blockquote>
<p>|————1次———|</p>
<h2 id="解释器类型"><a href="#解释器类型" class="headerlink" title="解释器类型"></a>解释器类型</h2><ol start="18">
<li><p>CPython（C语言开发)</p>
</li>
<li><p>Jython (java开发)</p>
</li>
<li><p>IronPython (.net开发)</p>
</li>
</ol>
<h1 id="数据基本运算"><a href="#数据基本运算" class="headerlink" title="数据基本运算"></a>数据基本运算</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="pycharm常用快捷键"><a href="#pycharm常用快捷键" class="headerlink" title="pycharm常用快捷键"></a>pycharm常用快捷键</h3><ol start="21">
<li><p>移动到本行开头：home键</p>
</li>
<li><p>移动到本行末尾：end键盘</p>
</li>
<li><p>注释代码：ctrl + &#x2F;</p>
</li>
<li><p>复制行：ctrl +d</p>
</li>
<li><p>选择列：鼠标左键 + alt</p>
</li>
<li><p>移动行：shift + alt + 上下箭头</p>
</li>
<li><p>智能提示：ctrl + space</p>
</li>
<li><p>代码格式化：ctrl+alt+l</p>
</li>
</ol>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><blockquote>
<p>给人看的，通常是对代码的描述信息。</p>
</blockquote>
<ol start="29">
<li><p>单行注释：以#号开头。</p>
</li>
<li><p>多行注释：三引号开头，三引号结尾。</p>
</li>
</ol>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>表示一个功能，函数定义者是提供功能的人，函数调用者是使用功能的人。</p>
<p>例如：</p>
<ol start="31">
<li><p>print(数据) 作用：将括号中的内容显示在控制台中</p>
</li>
<li><p>变量 &#x3D; input(“需要显示的内容”) 作用：将用户输入的内容赋值给变量</p>
</li>
</ol>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ol start="33">
<li><p>定义：关联一个对象的标识符。</p>
</li>
<li><p>命名：必须是字母或下划线开头，后跟字母、数字、下划线。</p>
</li>
</ol>
<p>不能使用关键字(蓝色)，否则发生语法错误：SyntaxError: invalid syntax。</p>
<ol start="35">
<li>建议命名：字母小写，多个单词以下划线隔开。</li>
</ol>
<p>class_name</p>
<ol start="36">
<li><p>赋值：创建一个变量或改变一个变量关联的数据。</p>
</li>
<li><p>语法：变量名 &#x3D; 数据</p>
</li>
</ol>
<p>变量名1 &#x3D; 变量名2 &#x3D; 数据</p>
<p>变量名1, 变量名2, &#x3D; 数据1, 数据2</p>
<h2 id="del-语句"><a href="#del-语句" class="headerlink" title="del 语句"></a>del 语句</h2><ol start="38">
<li>语法:</li>
</ol>
<blockquote>
<p>del 变量名1, 变量名2</p>
</blockquote>
<ol start="39">
<li>作用：</li>
</ol>
<blockquote>
<p>用于删除变量,同时解除与对象的关联.如果可能则释放对象。</p>
</blockquote>
<ol start="40">
<li>自动化内存管理的引用计数：</li>
</ol>
<blockquote>
<p>每个对象记录被变量绑定(引用)的数量,当为0时被销毁。</p>
</blockquote>
<h2 id="核心数据类型"><a href="#核心数据类型" class="headerlink" title="核心数据类型"></a>核心数据类型</h2><ol start="41">
<li><p>在python中变量没有类型，但关联的对象有类型。</p>
</li>
<li><p>通过type函数可查看。</p>
</li>
</ol>
<h3 id="空值对象-None"><a href="#空值对象-None" class="headerlink" title="空值对象 None"></a>空值对象 None</h3><ol start="43">
<li><p>表示不存在的特殊对象。</p>
</li>
<li><p>作用：占位和解除与对象的关联。</p>
</li>
</ol>
<h3 id="整形int"><a href="#整形int" class="headerlink" title="整形int"></a>整形int</h3><ol start="45">
<li>表示整数，包含正数、负数、0。</li>
</ol>
<blockquote>
<p>如： -5, 100, 0</p>
</blockquote>
<ol start="46">
<li>字面值：</li>
</ol>
<blockquote>
<p>十进制：5</p>
</blockquote>
<p>二进制：0b开头，后跟1或者1</p>
<p>八进制：0o开头，后跟0~7</p>
<p>十六进制：0x开头，后跟0<del>9,A</del>F,a~f</p>
<h3 id="浮点型float"><a href="#浮点型float" class="headerlink" title="浮点型float"></a>浮点型float</h3><ol start="47">
<li><p>表示小数，包含正数、负数，0.0)。</p>
</li>
<li><p>字面值：</p>
</li>
</ol>
<ul>
<li><p>小数：1.0 2.5</p>
</li>
<li><p>科学计数法：e&#x2F;E (正负号) 指数</p>
</li>
<li><p>1.23e-2 (等同于0.0123)</p>
</li>
<li><p>1.23456e5(等同于123456.0)</p>
</li>
</ul>
<h3 id="字符串str"><a href="#字符串str" class="headerlink" title="字符串str"></a>字符串str</h3><p>是用来记录文本信息(文字信息)。</p>
<p>字面值：双引号</p>
<h3 id="复数complex"><a href="#复数complex" class="headerlink" title="复数complex"></a>复数complex</h3><p>由实部和虚部组成的数字。</p>
<p>虚部是以j或J结尾。</p>
<p>字面值： 1j 1+1j 1-1j</p>
<h3 id="布尔bool"><a href="#布尔bool" class="headerlink" title="布尔bool"></a>布尔bool</h3><p>用来表示真和假的类型</p>
<p>True 表示真(条件满足或成立)，本质是1</p>
<p>False 表示假(条件不满足或不成立)，本质是0</p>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><ol start="49">
<li><p>转换为整形: int(数据)</p>
</li>
<li><p>转换为浮点型:float(数据)</p>
</li>
<li><p>转换为字符串:str(数据)</p>
</li>
<li><p>转换为布尔:bool(数据)</p>
</li>
</ol>
<p>结果为False：bool(0) bool(0.0) bool(None)</p>
<ol start="53">
<li>混合类型自动升级：</li>
</ol>
<ul>
<li><p>1 + 2.14 返回的结果是 3.14</p>
</li>
<li><p>1 + 3.0 返回结果是: 4.0</p>
</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><ul>
<li>加法</li>
</ul>
<ul>
<li>减法</li>
</ul>
<ul>
<li>乘法</li>
</ul>
<ul>
<li><p>&#x2F; 除法：结果为浮点数</p>
</li>
<li><p>&#x2F;&#x2F; 地板除：除的结果去掉小数部分</p>
</li>
<li><p>% 求余</p>
</li>
<li><p>** 幂运算</p>
</li>
</ul>
<p>优先级从高到低：</p>
<ul>
<li><p>()</p>
</li>
<li><p>**</p>
</li>
</ul>
<ul>
<li>&#x2F; % &#x2F;&#x2F;</li>
</ul>
<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<h3 id="增强运算符"><a href="#增强运算符" class="headerlink" title="增强运算符"></a>增强运算符</h3><p>y +&#x3D; x 等同于 y &#x3D; y + x</p>
<p>y -&#x3D; x 等同于 y &#x3D; y - x</p>
<p>y *&#x3D; x 等同于 y &#x3D; y * x</p>
<p>y &#x2F;&#x3D; x 等同于 y &#x3D; y &#x2F; x</p>
<p>y &#x2F;&#x2F;&#x3D; x 等同于 y &#x3D; y &#x2F;&#x2F; x</p>
<p>y %&#x3D; x 等同于 y &#x3D; y % x</p>
<p>y **&#x3D; x 等同于 y &#x3D; y ** x</p>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><ul>
<li><p>&lt;		小于</p>
</li>
<li><p>&lt;&#x3D;		小于等于</p>
</li>
<li><p>&gt;		大于</p>
</li>
<li><p>&gt;&#x3D;		大于等于</p>
</li>
<li><p>&#x3D;&#x3D;		等于</p>
</li>
<li><p>!&#x3D;		不等于</p>
</li>
</ul>
<p>返回布尔类型的值</p>
<p>比较运算的数学表示方式:0 &lt;&#x3D; x &lt;&#x3D; 100</p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><h4 id="与and"><a href="#与and" class="headerlink" title="与and"></a>与and</h4><p>表示并且的关系，一假俱假。</p>
<p>示例:</p>
<p>True and True # True</p>
<p>True and False # False</p>
<p>False and True # False</p>
<p>False and False # False</p>
<h4 id="或or"><a href="#或or" class="headerlink" title="或or"></a>或or</h4><p>表示或者的关系，一真俱真</p>
<p>示例:</p>
<p>True or True # True</p>
<p>True or False # True</p>
<p>False or True # True</p>
<p>False or False # False</p>
<h4 id="非-not"><a href="#非-not" class="headerlink" title="非 not"></a>非 not</h4><p>表示取反</p>
<p>例如：</p>
<p>not True # 返回False</p>
<p>not False # 返回True</p>
<h4 id="短路运算"><a href="#短路运算" class="headerlink" title="短路运算"></a>短路运算</h4><p>一但结果确定，后面的语句将不再执行。</p>
<h3 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a>身份运算符</h3><p>语法:</p>
<p>x is y</p>
<p>x is not y</p>
<p>作用：</p>
<p>is 用于判断两个对象是否是同一个对象,是时返回True,否则返回False。</p>
<p>is not 的作用与is相反</p>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>高到低：</p>
<ul>
<li><p>算数运算符</p>
</li>
<li><p>比较运算符</p>
</li>
<li><p>快捷运算符</p>
</li>
<li><p>身份运算符</p>
</li>
<li><p>逻辑运算符</p>
</li>
</ul>
<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h2 id="行"><a href="#行" class="headerlink" title="行"></a>行</h2><ol start="54">
<li><p>物理行：程序员编写代码的行。</p>
</li>
<li><p>逻辑行：python解释器需要执行的指令。</p>
</li>
<li><p>建议一个逻辑行在一个物理行上。</p>
</li>
<li><p>如果一个物理行中使用多个逻辑行，需要使用分号；隔开。</p>
</li>
<li><p>如果逻辑行过长，可以使用隐式换行或显式换行。</p>
</li>
</ol>
<p>隐式换行：所有括号的内容换行,称为隐式换行</p>
<p>括号包括: () [] {} 三种</p>
<p>显式换行：通过折行符 \ (反斜杠)换行，必须放在一行的末尾，目的是告诉解释器,下一行也是本行的语句。</p>
<h2 id="pass-语句"><a href="#pass-语句" class="headerlink" title="pass 语句"></a>pass 语句</h2><p>通常用来填充语法空白。</p>
<h2 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h2><h3 id="If-elif-else-语句"><a href="#If-elif-else-语句" class="headerlink" title="If elif else 语句"></a>If elif else 语句</h3><ol start="58">
<li>作用:</li>
</ol>
<p>让程序根据条件选择性的执行语句。</p>
<ol start="59">
<li>语法:</li>
</ol>
<p>if 条件1:</p>
<p>​	语句块1</p>
<p>elif 条件2:</p>
<p>​	语句块2</p>
<p>else:</p>
<p>​	语句块3</p>
<ol start="60">
<li>说明:</li>
</ol>
<p>elif 子句可以有0个或多个。</p>
<p>else 子句可以有0个或1个，且只能放在if语句的最后。</p>
<h3 id="if-语句的真值表达式"><a href="#if-语句的真值表达式" class="headerlink" title="if 语句的真值表达式"></a>if 语句的真值表达式</h3><p>if 100:</p>
<p>​	print(“真值”)</p>
<p>等同于</p>
<p>if bool(100):</p>
<p>​	print(“真值”)</p>
<h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><p>语法：变量 &#x3D; 结果1 if 条件 else 结果2</p>
<p>作用：根据条件(True&#x2F;False) 来决定返回结果1还是结果2。</p>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><ol start="61">
<li>作用:</li>
</ol>
<p>可以让一段代码满足条件，重复执行。</p>
<ol start="62">
<li>语法:</li>
</ol>
<p>while 条件:</p>
<p>​	满足条件执行的语句</p>
<p>else:</p>
<p>​	不满足条件执行的语句</p>
<ol start="63">
<li>说明:</li>
</ol>
<p>else子句可以省略。</p>
<p>在循环体内用break终止循环时,else子句不执行。</p>
<h3 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h3><ol start="64">
<li>作用:</li>
</ol>
<p>用来遍历可迭代对象的数据元素。</p>
<p>可迭代对象是指能依次获取数据元素的对象，例如：容器类型。</p>
<ol start="65">
<li>语法:</li>
</ol>
<p>for 变量列表 in 可迭代对象:</p>
<p>​	语句块1</p>
<p>else:</p>
<p>​	语句块2</p>
<ol start="66">
<li>说明:</li>
</ol>
<p>else子句可以省略。</p>
<p>在循环体内用break终止循环时,else子句不执行。</p>
<h3 id="range-函数"><a href="#range-函数" class="headerlink" title="range 函数"></a>range 函数</h3><ol start="67">
<li>作用:</li>
</ol>
<p>用来创建一个生成一系列整数的可迭代对象(也叫整数序列生成器)。</p>
<ol start="68">
<li>语法:</li>
</ol>
<p>range(开始点，结束点，间隔)</p>
<ol start="69">
<li>说明:</li>
</ol>
<p>函数返回的可迭代对象可以用for取出其中的元素</p>
<p>返回的数字不包含结束点</p>
<p>开始点默认为0</p>
<p>间隔默认值为1</p>
<h2 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h2><h3 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h3><ol start="70">
<li><p>跳出循环体，后面的代码不再执行。</p>
</li>
<li><p>可以让while语句的else部分不执行。</p>
</li>
</ol>
<h3 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h3><p>跳过本次，继续下次循环。</p>
<h1 id="容器类型"><a href="#容器类型" class="headerlink" title="容器类型"></a>容器类型</h1><h2 id="通用操作"><a href="#通用操作" class="headerlink" title="通用操作"></a>通用操作</h2><h3 id="数学运算符"><a href="#数学运算符" class="headerlink" title="数学运算符"></a>数学运算符</h3><ol start="72">
<li><p>+：用于拼接两个容器</p>
</li>
<li><p>+&#x3D;：用原容器与右侧容器拼接,并重新绑定变量</p>
</li>
<li><p>*：重复生成容器元素</p>
</li>
<li><p>*&#x3D;：用原容器生成重复元素, 并重新绑定变量</p>
</li>
<li><p>&lt; &lt;&#x3D; &gt; &gt;&#x3D; &#x3D;&#x3D; !&#x3D;：依次比较两个容器中元素,一但不同则返回比较结果。</p>
</li>
</ol>
<h3 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h3><ol start="77">
<li>语法：</li>
</ol>
<p>数据 in 序列</p>
<p>数据 not in 序列</p>
<ol start="78">
<li>作用：</li>
</ol>
<p>如果在指定的序列中找到值，返回bool类型。</p>
<h3 id="索引index"><a href="#索引index" class="headerlink" title="索引index"></a>索引index</h3><ol start="79">
<li><p>作用：定位单个容器元素</p>
</li>
<li><p>语法：容器[整数]</p>
</li>
<li><p>说明：</p>
</li>
</ol>
<p>正向索引从0开始，第二个索引为1，最后一个为len(s)-1。</p>
<p>反向索引从-1开始,-1代表最后一个,-2代表倒数第二个,以此类推,第一个是-len(s)。</p>
<h3 id="切片slice"><a href="#切片slice" class="headerlink" title="切片slice"></a>切片slice</h3><ol start="82">
<li>作用：</li>
</ol>
<p>定位多个容器元素。</p>
<ol start="83">
<li>语法：</li>
</ol>
<p>容器[(开始索引):(结束索引)(:(步长))]</p>
<ol start="84">
<li>说明：</li>
</ol>
<p>小括号()括起的部分代表可省略</p>
<p>结束索引不包含该位置元素</p>
<p>步长是切片每次获取完当前元素后移动的偏移量</p>
<h3 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h3><ol start="85">
<li><p>len(x) 返回序列的长度</p>
</li>
<li><p>max(x) 返回序列的最大值元素</p>
</li>
<li><p>min(x) 返回序列的最小值元素</p>
</li>
<li><p>sum(x) 返回序列中所有元素的和(元素必须是数值类型)</p>
</li>
</ol>
<h2 id="字符串-str"><a href="#字符串-str" class="headerlink" title="字符串 str"></a>字符串 str</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>由一系列字符组成的不可变序列容器，存储的是字符的编码值。</p>
</blockquote>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><ol start="89">
<li><p>字节byte：计算机最小存储单位，等于8 位bit.</p>
</li>
<li><p>字符：单个的数字，文字与符号。</p>
</li>
<li><p>字符集(码表)：存储字符与二进制序列的对应关系。</p>
</li>
<li><p>编码：将字符转换为对应的二进制序列的过程。</p>
</li>
<li><p>解码：将二进制序列转换为对应的字符的过程。</p>
</li>
<li><p>编码方式：</p>
</li>
</ol>
<p>–ASCII编码：包含英文、数字等字符，每个字符1个字节。</p>
<p>–GBK编码：兼容ASCII编码，包含21003个中文；英文1个字节，汉字2个字节。</p>
<p>–Unicode字符集：国际统一编码，旧字符集每个字符2字节，新字符集4字节。</p>
<p>–UTF-8编码：Unicode的存储与传输方式，英文1字节，中文3字节。</p>
<h4 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h4><ol start="95">
<li><p>ord(字符串):返回该字符串的Unicode码。</p>
</li>
<li><p>chr(整数):返回该整数对应的字符串。</p>
</li>
</ol>
<h3 id="字面值"><a href="#字面值" class="headerlink" title="字面值"></a>字面值</h3><h4 id="单引和双引号的区别"><a href="#单引和双引号的区别" class="headerlink" title="单引和双引号的区别"></a>单引和双引号的区别</h4><ol start="97">
<li><p>单引号内的双引号不算结束符</p>
</li>
<li><p>双引号内的单引号不算结束符</p>
</li>
</ol>
<h4 id="三引号作用"><a href="#三引号作用" class="headerlink" title="三引号作用"></a>三引号作用</h4><ol start="99">
<li><p>换行会自动转换为换行符\n</p>
</li>
<li><p>三引号内可以包含单引号和双引号</p>
</li>
<li><p>作为文档字符串</p>
</li>
</ol>
<h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4><ol start="102">
<li>改变字符的原始含义。</li>
</ol>
<blockquote>
<p>&#39; &quot; &quot;“” \n \ \t \0 空字符</p>
</blockquote>
<ol start="103">
<li>原始字符串：取消转义。</li>
</ol>
<p>a &#x3D; r”C:\newfile\test.py”</p>
<h4 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h4><ol start="104">
<li>定义：</li>
</ol>
<blockquote>
<p>生成一定格式的字符串。</p>
</blockquote>
<ol start="105">
<li>语法：</li>
</ol>
<blockquote>
<p>字符串%(变量)</p>
</blockquote>
<p>“我的名字是%s,年龄是%s” % (name, age)</p>
<ol start="106">
<li>类型码：</li>
</ol>
<blockquote>
<p>%s 字符串 %d整数 %f 浮点数</p>
</blockquote>
<h2 id="列表-list"><a href="#列表-list" class="headerlink" title="列表 list"></a>列表 list</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>由一系列变量组成的可变序列容器。</p>
<h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><ol start="107">
<li>创建列表：</li>
</ol>
<blockquote>
<p>列表名 &#x3D; []</p>
</blockquote>
<p>列表名 &#x3D; list(可迭代对象)</p>
<ol start="108">
<li>添加元素：</li>
</ol>
<blockquote>
<p>列表名.append(元素)</p>
</blockquote>
<p>列表.insert(索引，元素)</p>
<ol start="109">
<li>定位元素：</li>
</ol>
<blockquote>
<p>列表名[索引] &#x3D; 元素</p>
</blockquote>
<p>变量 &#x3D; 列表名[索引]</p>
<p>变量 &#x3D; 列表名[切片] # 赋值给变量的是切片所创建的新列表</p>
<p>列表名[切片] &#x3D; 容器 # 右侧必须是可迭代对象，左侧切片没有创建新列表。遍历列表：</p>
<p>正向：</p>
<p>for 变量名 in 列表名:</p>
<p>变量名就是元素</p>
<p>反向：</p>
<p>for 索引名 in range(len(列表名)-1,-1,-1):</p>
<p>列表名[索引名]就是元素</p>
<ol start="110">
<li>删除元素：</li>
</ol>
<blockquote>
<p>列表名.remove(元素)</p>
</blockquote>
<p>del 列表名[索引或切片]</p>
<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>浅拷贝：复制过程中,只复制一层变量,不会复制深层变量绑定的对象的复制过程。</p>
<p>深拷贝：复制整个依懒的变量。</p>
<h3 id="列表VS字符串"><a href="#列表VS字符串" class="headerlink" title="列表VS字符串"></a>列表VS字符串</h3><ol start="111">
<li><p>列表和字符串都是序列,元素之间有先后顺序关系。</p>
</li>
<li><p>字符串是不可变的序列,列表是可变的序列。</p>
</li>
<li><p>字符串中每个元素只能存储字符,而列表可以存储任意类型。</p>
</li>
<li><p>列表和字符串都是可迭代对象。</p>
</li>
<li><p>函数：</p>
</li>
</ol>
<blockquote>
<p>将多个字符串拼接为一个。</p>
</blockquote>
<p>result &#x3D; “连接符”.join(列表)</p>
<p>将一个字符串拆分为多个。</p>
<p>列表 &#x3D; “a-b-c-d”.split(“分隔符”)</p>
<h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h3><ol start="116">
<li>定义：</li>
</ol>
<blockquote>
<p>使用简易方法，将可迭代对象转换为列表。</p>
</blockquote>
<ol start="117">
<li>语法：</li>
</ol>
<blockquote>
<p>变量 &#x3D; [表达式 for 变量 in 可迭代对象]</p>
</blockquote>
<p>变量 &#x3D; [表达式 for 变量 in 可迭代对象 if 条件]</p>
<ol start="118">
<li>说明:</li>
</ol>
<blockquote>
<p>如果if真值表达式的布尔值为False,则可迭代对象生成的数据将被丢弃。</p>
</blockquote>
<h3 id="列表推导式嵌套"><a href="#列表推导式嵌套" class="headerlink" title="列表推导式嵌套"></a>列表推导式嵌套</h3><ol start="119">
<li>语法：</li>
</ol>
<blockquote>
<p>变量 &#x3D; [表达式 for 变量1 in 可迭代对象1 for 变量2 in可迭代对象2]</p>
</blockquote>
<ol start="120">
<li>传统写法：</li>
</ol>
<p>result &#x3D; []</p>
<p>for r in [“a”, “b”, “c”]:</p>
<p>for c in [“A”, “B”, “C”]:</p>
<p>result.append(r + c)</p>
<ol start="121">
<li>推导式写法：</li>
</ol>
<p>result &#x3D; [r + c for r in list01 for c in list02]</p>
<h2 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组 tuple"></a>元组 tuple</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><ol start="122">
<li><p>由一系列变量组成的不可变序列容器。</p>
</li>
<li><p>不可变是指一但创建，不可以再添加&#x2F;删除&#x2F;修改元素。</p>
</li>
</ol>
<h3 id="基础操作-1"><a href="#基础操作-1" class="headerlink" title="基础操作"></a>基础操作</h3><ol start="124">
<li>创建空元组：</li>
</ol>
<p>元组名 &#x3D; ()</p>
<p>元组名 &#x3D; tuple()</p>
<ol start="125">
<li>创建非空元组：</li>
</ol>
<p>元组名 &#x3D; (20,)</p>
<p>元组名 &#x3D; (1, 2, 3)</p>
<p>元组名 &#x3D; 100,200,300</p>
<p>元组名 &#x3D; tuple(可迭代对象)</p>
<ol start="126">
<li>获取元素：</li>
</ol>
<p>变量 &#x3D; 元组名[索引]</p>
<p>变量 &#x3D; 元组名[切片] # 赋值给变量的是切片所创建的新列表</p>
<ol start="127">
<li>遍历元组：</li>
</ol>
<p>正向：</p>
<p>for 变量名 in 列表名:</p>
<p>变量名就是元素</p>
<p>反向：</p>
<p>for 索引名 in range(len(列表名)-1,-1,-1):</p>
<p>元组名[索引名]就是元素</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol start="128">
<li><p>元组与列表都可以存储一系列变量，由于列表会预留内存空间，所以可以增加元素。</p>
</li>
<li><p>元组会按需分配内存，所以如果变量数量固定，建议使用元组，因为占用空间更小。</p>
</li>
<li><p>应用：</p>
</li>
</ol>
<p>变量交换的本质就是创建元组：x, y &#x3D; （y, x ）</p>
<p>格式化字符串的本质就是创建元祖：”姓名:%s, 年龄:%d” % (“tarena”, 15)</p>
<h2 id="字典-dict"><a href="#字典-dict" class="headerlink" title="字典 dict"></a>字典 dict</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><ol start="131">
<li><p>由一系列键值对组成的可变散列容器。</p>
</li>
<li><p>散列：对键进行哈希运算，确定在内存中的存储位置，每条数据存储无先后顺序。</p>
</li>
<li><p>键必须惟一且不可变(字符串&#x2F;数字&#x2F;元组)，值没有限制。</p>
</li>
</ol>
<h3 id="基础操作-2"><a href="#基础操作-2" class="headerlink" title="基础操作"></a>基础操作</h3><ol start="134">
<li>创建字典：</li>
</ol>
<p>字典名 &#x3D; {键1：值1，键2：值2}</p>
<p>字典名 &#x3D; dict (可迭代对象)</p>
<ol start="135">
<li>添加&#x2F;修改元素：</li>
</ol>
<p>语法:</p>
<p>字典名[键] &#x3D; 数据</p>
<p>说明:</p>
<p>键不存在，创建记录。</p>
<p>键存在，修改值。</p>
<ol start="136">
<li>获取元素：</li>
</ol>
<p>变量 &#x3D; 字典名[键] # 没有键则错误</p>
<ol start="137">
<li>遍历字典：</li>
</ol>
<p>for 键名 in 字典名:</p>
<p>​	字典名[键名]</p>
<p>for 键名,值名 in 字典名.items():</p>
<p>语句</p>
<ol start="138">
<li>删除元素：</li>
</ol>
<blockquote>
<p>del 字典名[键]</p>
</blockquote>
<h3 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h3><ol start="139">
<li>定义：</li>
</ol>
<p>使用简易方法，将可迭代对象转换为字典。</p>
<ol start="140">
<li>语法:</li>
</ol>
<p>{键:值 for 变量 in 可迭代对象}</p>
<p>{键:值 for 变量 in 可迭代对象 if 条件}</p>
<h3 id="字典-VS-列表"><a href="#字典-VS-列表" class="headerlink" title="字典 VS 列表"></a>字典 VS 列表</h3><ol start="141">
<li><p>都是可变容器。</p>
</li>
<li><p>获取元素方式不同,列表用索引,字典用键。</p>
</li>
<li><p>字典的插入,删除,修改的速度快于列表。</p>
</li>
<li><p>列表的存储是有序的,字典的存储是无序的。</p>
</li>
</ol>
<h2 id="集合-set"><a href="#集合-set" class="headerlink" title="集合 set"></a>集合 set</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><ol start="145">
<li><p>由一系列不重复的不可变类型变量(元组&#x2F;数&#x2F;字符串)组成的可变散列容器。</p>
</li>
<li><p>相当于只有键没有值的字典(键则是集合的数据)。</p>
</li>
</ol>
<h3 id="基础操作-3"><a href="#基础操作-3" class="headerlink" title="基础操作"></a>基础操作</h3><ol start="147">
<li>创建空集合：</li>
</ol>
<p>集合名 &#x3D; set()</p>
<p>集合名 &#x3D; set(可迭代对象)</p>
<ol start="148">
<li>创建具有默认值集合：</li>
</ol>
<p>集合名 &#x3D; {1, 2, 3}</p>
<p>集合名 &#x3D; set(可迭代对象)</p>
<ol start="149">
<li>添加元素：</li>
</ol>
<p>集合名.add(元素)</p>
<ol start="150">
<li>删除元素：</li>
</ol>
<p>集合名.discard(元素)</p>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><ol start="151">
<li>交集&amp;：返回共同元素。</li>
</ol>
<p>s1 &#x3D; {1, 2, 3}</p>
<p>s2 &#x3D; {2, 3, 4}</p>
<p>s3 &#x3D; s1 &amp; s2 # {2, 3}</p>
<ol start="152">
<li>并集：返回不重复元素</li>
</ol>
<p>s1 &#x3D; {1, 2, 3}</p>
<p>s2 &#x3D; {2, 3, 4}</p>
<p>s3 &#x3D; s1 | s2 # {1, 2, 3, 4}</p>
<ol start="153">
<li>补集-：返回只属于其中之一的元素</li>
</ol>
<p>s1 &#x3D; {1, 2, 3}</p>
<p>s2 &#x3D; {2, 3, 4}</p>
<p>s1 - s2 # {1} 属于s1但不属于s2</p>
<p>补集^：返回不同的的元素</p>
<p>s1 &#x3D; {1, 2, 3}</p>
<p>s2 &#x3D; {2, 3, 4}</p>
<p>s3 &#x3D; s1 ^ s2 # {1, 4} 等同于(s1-s2 | s2-s1)</p>
<ol start="154">
<li><p>子集&lt;：判断一个集合的所有元素是否完全在另一个集合中</p>
</li>
<li><p>超集&gt;：判断一个集合是否具有另一个集合的所有元素</p>
</li>
</ol>
<p>s1 &#x3D; {1, 2, 3}</p>
<p>s2 &#x3D; {2, 3}</p>
<p>s2 &lt; s1 # True</p>
<p>s1 &gt; s2 # True</p>
<ol start="156">
<li>相同或不同&#x3D;&#x3D; !&#x3D;：判断集合中的所有元素是否和另一个集合相同。</li>
</ol>
<p>s1 &#x3D; {1, 2, 3}</p>
<p>s2 &#x3D; {3, 2, 1}</p>
<p>s1 &#x3D;&#x3D; s2 # True</p>
<p>s1 !&#x3D; s2 # False</p>
<p>子集或相同,超集或相同 &lt;&#x3D; &gt;&#x3D;</p>
<h3 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h3><ol start="157">
<li>定义：</li>
</ol>
<p>使用简易方法，将可迭代对象转换为集合。</p>
<ol start="158">
<li>语法:</li>
</ol>
<p>{表达式 for 变量 in 可迭代对象}</p>
<p>{表达式 for 变量 in 可迭代对象 if 条件}</p>
<h1 id="函数-function"><a href="#函数-function" class="headerlink" title="函数 function"></a>函数 function</h1><h2 id="pycharm相关设置"><a href="#pycharm相关设置" class="headerlink" title="pycharm相关设置"></a>pycharm相关设置</h2><ol start="159">
<li>“代码自动完成”时间延时设置</li>
</ol>
<blockquote>
<p>File -&gt; Settings -&gt; Editor -&gt; General -&gt; Code Completion -&gt; Autopopup in (ms):0</p>
</blockquote>
<ol start="160">
<li>快捷键：</li>
</ol>
<blockquote>
<p>Ctrl + P 参数信息（在方法中调用参数）</p>
</blockquote>
<p>Ctrl + Q 快速查看文档</p>
<p>Ctrl + Alt + M 提取方法</p>
<h2 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h2><ol start="161">
<li><p>用于封装一个特定的功能，表示一个功能或者行为。</p>
</li>
<li><p>函数是可以重复执行的语句块, 可以重复调用。</p>
</li>
</ol>
<h2 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h2><p>提高代码的可重用性和可维护性（代码层次结构更清晰）。</p>
<h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><ol start="163">
<li>语法：</li>
</ol>
<blockquote>
<p>def 函数名(形式参数):</p>
</blockquote>
<p>  函数体</p>
<ol start="164">
<li>说明：</li>
</ol>
<blockquote>
<p>def 关键字：全称是define，意为”定义”。</p>
</blockquote>
<p>函数名：对函数体中语句的描述，规则与变量名相同。</p>
<p>形式参数：方法定义者要求调用者提供的信息。</p>
<p>函数体：完成该功能的语句。</p>
<ol start="165">
<li>函数的第一行语句建议使用文档字符串描述函数的功能与参数。</li>
</ol>
<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><ol start="166">
<li><p>语法：函数名(实际参数)</p>
</li>
<li><p>说明：根据形参传递内容。</p>
</li>
</ol>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><ol start="168">
<li>定义：</li>
</ol>
<blockquote>
<p>方法定义者告诉调用者的结果。</p>
</blockquote>
<ol start="169">
<li>语法：</li>
</ol>
<blockquote>
<p>return 数据 </p>
</blockquote>
<ol start="170">
<li>说明：</li>
</ol>
<blockquote>
<p>return后没有语句，相当于返回 None。</p>
</blockquote>
<p>函数体没有return，相当于返回None。</p>
<h2 id="可变／不可变类型在传参时的区别"><a href="#可变／不可变类型在传参时的区别" class="headerlink" title="可变／不可变类型在传参时的区别"></a>可变／不可变类型在传参时的区别</h2><ol start="171">
<li>不可变类型参数有:</li>
</ol>
<blockquote>
<p>数值型(整数，浮点数,复数)</p>
</blockquote>
<p>布尔值bool</p>
<p>None 空值</p>
<p>字符串str</p>
<p>元组tuple</p>
<p>固定集合frozenset</p>
<ol start="172">
<li>可变类型参数有:</li>
</ol>
<blockquote>
<p>列表 list</p>
</blockquote>
<p>字典 dict</p>
<p>集合 set</p>
<ol start="173">
<li>传参说明：</li>
</ol>
<blockquote>
<p>不可变类型的数据传参时，函数内部不会改变原数据的值。</p>
</blockquote>
<p>可变类型的数据传参时，函数内部可以改变原数据。</p>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><h3 id="实参传递方式argument"><a href="#实参传递方式argument" class="headerlink" title="实参传递方式argument"></a>实参传递方式argument</h3><h4 id="位置传参"><a href="#位置传参" class="headerlink" title="位置传参"></a>位置传参</h4><p>定义：实参与形参的位置依次对应。</p>
<h4 id="序列传参"><a href="#序列传参" class="headerlink" title="序列传参"></a>序列传参</h4><p>定义：实参用*将序列拆解后与形参的位置依次对应。</p>
<h4 id="关键字传参"><a href="#关键字传参" class="headerlink" title="关键字传参"></a>关键字传参</h4><p>定义：实参根据形参的名字进行对应。</p>
<h4 id="字典关键字传参"><a href="#字典关键字传参" class="headerlink" title="字典关键字传参"></a>字典关键字传参</h4><ol start="174">
<li><p>定义：实参用**将字典拆解后与形参的名字进行对应。</p>
</li>
<li><p>作用：配合形参的缺省参数，可以使调用者随意传参。</p>
</li>
</ol>
<h3 id="形参定义方式parameter"><a href="#形参定义方式parameter" class="headerlink" title="形参定义方式parameter"></a>形参定义方式parameter</h3><h4 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h4><ol start="176">
<li>语法：</li>
</ol>
<blockquote>
<p>def 函数名(形参名1&#x3D;默认实参1, 形参名2&#x3D;默认实参2, …):</p>
</blockquote>
<p>函数体</p>
<ol start="177">
<li>说明：</li>
</ol>
<blockquote>
<p>缺省参数必须自右至左依次存在，如果一个参数有缺省参数，则其右侧的所有参数都必须有缺省参数。</p>
</blockquote>
<p>缺省参数可以有0个或多个，甚至全部都有缺省参数。</p>
<h4 id="位置形参"><a href="#位置形参" class="headerlink" title="位置形参"></a>位置形参</h4><p>语法：</p>
<blockquote>
<p>def 函数名(形参名1, 形参名2, …):</p>
</blockquote>
<p>函数体</p>
<h4 id="星号元组形参"><a href="#星号元组形参" class="headerlink" title="星号元组形参"></a>星号元组形参</h4><ol start="178">
<li>语法：</li>
</ol>
<blockquote>
<p>def 函数名(*元组形参名):</p>
</blockquote>
<p>  函数体</p>
<ol start="179">
<li>作用：</li>
</ol>
<blockquote>
<p>收集多余的位置传参。</p>
</blockquote>
<ol start="180">
<li>说明：</li>
</ol>
<blockquote>
<p>一般命名为’args’</p>
</blockquote>
<p>形参列表中最多只能有一个</p>
<h4 id="命名关键字形参"><a href="#命名关键字形参" class="headerlink" title="命名关键字形参"></a>命名关键字形参</h4><ol start="181">
<li>语法：</li>
</ol>
<blockquote>
<p>def 函数名(*, 命名关键字形参1, 命名关键字形参2, …):</p>
</blockquote>
<p>函数体</p>
<p>def 函数名(*args, 命名关键字形参1, 命名关键字形参2, …):<br>  函数体</p>
<ol start="182">
<li>作用：</li>
</ol>
<blockquote>
<p>强制实参使用关键字传参</p>
</blockquote>
<h4 id="双星号字典形参"><a href="#双星号字典形参" class="headerlink" title="双星号字典形参"></a>双星号字典形参</h4><ol start="183">
<li>语法：</li>
</ol>
<p>def 函数名(**字典形参名):</p>
<p>​		函数体</p>
<ol start="184">
<li>作用：</li>
</ol>
<p>收集多余的关键字传参</p>
<ol start="185">
<li>说明:</li>
</ol>
<p>一般命名为’kwargs’</p>
<p>形参列表中最多只能有一个</p>
<h4 id="参数自左至右的顺序"><a href="#参数自左至右的顺序" class="headerlink" title="参数自左至右的顺序"></a>参数自左至右的顺序</h4><p>位置形参 –&gt; 星号元组形参 –&gt; 命名关键字形参 –&gt; 双星号字典形参</p>
<h1 id="作用域LEGB"><a href="#作用域LEGB" class="headerlink" title="作用域LEGB"></a>作用域LEGB</h1><ol start="186">
<li><p>作用域：变量起作用的范围。</p>
</li>
<li><p>Local局部作用域：函数内部。</p>
</li>
<li><p>Enclosing 外部嵌套作用域 ：函数嵌套。</p>
</li>
<li><p>Global全局作用域：模块(.py文件)内部。</p>
</li>
<li><p>Builtin内置模块作用域：builtins.py文件。</p>
</li>
</ol>
<h2 id="变量名的查找规则"><a href="#变量名的查找规则" class="headerlink" title="变量名的查找规则"></a>变量名的查找规则</h2><ol start="191">
<li><p>由内到外：L -&gt; E -&gt; G -&gt; B</p>
</li>
<li><p>在访问变量时，先查找本地变量，然后是包裹此函数外部的函数内部的变量，之后是全局变量，最后是内置变量。</p>
</li>
</ol>
<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><ol start="193">
<li><p>定义在函数内部的变量(形参也是局部变量)</p>
</li>
<li><p>只能在函数内部使用</p>
</li>
<li><p>调用函数时才被创建，函数结束后自动销毁</p>
</li>
</ol>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><ol start="196">
<li><p>定义在函数外部,模块内部的变量。</p>
</li>
<li><p>在整个模块(py文件)范围内访问（但函数内不能将其直接赋值）。</p>
</li>
</ol>
<h2 id="global-语句"><a href="#global-语句" class="headerlink" title="global 语句"></a>global 语句</h2><ol start="198">
<li>作用：</li>
</ol>
<blockquote>
<p>在函数内部修改全局变量。</p>
</blockquote>
<p>在函数内部定义全局变量(全局声明)。</p>
<ol start="199">
<li>语法：</li>
</ol>
<blockquote>
<p>global 变量1, 变量2, …</p>
</blockquote>
<ol start="200">
<li>说明</li>
</ol>
<blockquote>
<p>在函数内直接为全局变量赋值，视为创建新的局部变量。</p>
</blockquote>
<p>不能先声明局部的变量，再用global声明为全局变量。</p>
<h2 id="nonlocal-语句"><a href="#nonlocal-语句" class="headerlink" title="nonlocal 语句"></a>nonlocal 语句</h2><ol start="201">
<li>作用：</li>
</ol>
<blockquote>
<p>在内层函数修改外层嵌套函数内的变量</p>
</blockquote>
<ol start="202">
<li>语法</li>
</ol>
<blockquote>
<p>nonlocal 变量名1,变量名2, …</p>
</blockquote>
<ol start="203">
<li>说明</li>
</ol>
<blockquote>
<p>在被嵌套的内函数中进行使用</p>
</blockquote>
<h1 id="面向对象-Object-Oriented"><a href="#面向对象-Object-Oriented" class="headerlink" title="面向对象 Object Oriented"></a>面向对象 Object Oriented</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h3><ol start="204">
<li>分析出解决问题的步骤，然后逐步实现。</li>
</ol>
<blockquote>
<p>例如：婚礼筹办</p>
</blockquote>
<p>– 发请柬（选照片、措词、制作）</p>
<p>– 宴席（场地、找厨师、准备桌椅餐具、计划菜品、购买食材）</p>
<p>– 婚礼仪式（定婚礼仪式流程、请主持人）</p>
<ol start="205">
<li><p>公式：程序 &#x3D; 算法 + 数据结构</p>
</li>
<li><p>优点：所有环节、细节自己掌控。</p>
</li>
<li><p>缺点：考虑所有细节，工作量大。</p>
</li>
</ol>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><ol start="208">
<li>找出解决问题的人，然后分配职责。</li>
</ol>
<blockquote>
<p>例如：婚礼筹办</p>
</blockquote>
<p>– 发请柬：找摄影公司（拍照片、制作请柬）</p>
<p>– 宴席：找酒店（告诉对方标准、数量、挑选菜品）</p>
<p>– 婚礼仪式：找婚庆公司（对方提供司仪、制定流程、提供设备、帮助执行）</p>
<ol start="209">
<li><p>公式：程序 &#x3D; 对象 + 交互</p>
</li>
<li><p>优点</p>
</li>
</ol>
<p> (1) 思想层面：</p>
<p>– 可模拟现实情景，更接近于人类思维。</p>
<p>– 有利于梳理归纳、分析解决问题。</p>
<p>(2) 技术层面：</p>
<p>– 高复用：对重复的代码进行封装，提高开发效率。</p>
<p>– 高扩展：增加新的功能，不修改以前的代码。</p>
<p>– 高维护：代码可读性好，逻辑清晰，结构规整。</p>
<ol start="211">
<li>缺点：学习曲线陡峭。</li>
</ol>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p><img src="/pictures/07python_basic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0.jpg" alt="面向对象概述"></p>
<ol start="212">
<li><p>抽象：从具体事物中抽离出共性、本质，舍弃个别、非本质过程。</p>
</li>
<li><p>类：一个抽象的概念，即生活中的”类别”。</p>
</li>
<li><p>对象：类的具体实例，即归属于某个类别的”个体”。</p>
</li>
<li><p>类是创建对象的”模板”。</p>
</li>
</ol>
<p>– 数据成员：名词类型的状态。</p>
<p>– 方法成员：动词类型的行为。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h4><ol start="216">
<li>代码</li>
</ol>
<blockquote>
<p>class 类名:</p>
</blockquote>
<p>“””文档说明”””</p>
<p>def <em>init</em>(self,参数列表):</p>
<p>self.实例变量 &#x3D; 参数</p>
<p>方法成员</p>
<ol start="217">
<li>说明</li>
</ol>
<p>– 类名所有单词首字母大写.</p>
<p>– <em>init</em> 也叫构造函数，创建对象时被调用，也可以省略。</p>
<p>– self 变量绑定的是被创建的对象，名称可以随意。</p>
<h4 id="创建对象-实例化"><a href="#创建对象-实例化" class="headerlink" title="创建对象(实例化)"></a>创建对象(实例化)</h4><p>变量 &#x3D; 构造函数 (参数列表)</p>
<h3 id="实例成员"><a href="#实例成员" class="headerlink" title="实例成员"></a>实例成员</h3><h4 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h4><ol start="218">
<li>语法</li>
</ol>
<p> </p>
<p>(1) 定义：对象.变量名</p>
<p>(2) 调用：对象.变量名</p>
<ol start="219">
<li>说明</li>
</ol>
<p>(1) 首次通过对象赋值为创建，再次赋值为修改.</p>
<p>w01 &#x3D; Wife()</p>
<p>w01.name &#x3D; “建宁”</p>
<p>w01.name &#x3D; “建宁公主”</p>
<p>(2) 通常在构造函数(<em>init</em>)中创建。</p>
<p>w01 &#x3D; Wife(“建宁公主,24)</p>
<p>print(w01.name)</p>
<p>(3) 每个对象存储一份，通过对象地址访问。</p>
<p> </p>
<ol start="220">
<li><p>作用：描述某个对象自己的数据。</p>
</li>
<li><p>__dict__：对象的属性，用于存储自身实例变量的字典。</p>
</li>
</ol>
<h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><ol start="222">
<li>语法</li>
</ol>
<p>(1) 定义： def 方法名称(self, 参数列表):</p>
<p>方法体</p>
<p>(2) 调用： 对象地址.实例方法名(参数列表)</p>
<p>不建议通过类名访问实例方法</p>
<ol start="223">
<li>说明</li>
</ol>
<p>(1) 至少有一个形参，第一个参数绑定调用这个方法的对象,一般命名为”self”。</p>
<p>(2) 无论创建多少对象，方法只有一份，并且被所有对象共享。</p>
<ol start="224">
<li>作用：表示对象行为。</li>
</ol>
<h3 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h3><h4 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h4><ol start="225">
<li>语法</li>
</ol>
<p> (1) 定义：在类中，方法外定义变量。</p>
<blockquote>
<p>class 类名:</p>
</blockquote>
<p>变量名 &#x3D; 表达式</p>
<p>(2) 调用：类名.变量名</p>
<p>不建议通过对象访问类变量</p>
<ol start="226">
<li>说明</li>
</ol>
<p>(1) 存储在类中。</p>
<p>(2) 只有一份，被所有对象共享。</p>
<ol start="227">
<li>作用：描述所有对象的共有数据。</li>
</ol>
<h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h4><ol start="228">
<li>语法</li>
</ol>
<p> (1) 定义：</p>
<blockquote>
<p>@classmethod</p>
</blockquote>
<p>def 方法名称(cls,参数列表):</p>
<p>方法体</p>
<p>(2) 调用：类名.方法名(参数列表)</p>
<blockquote>
<p>不建议通过对象访问类方法</p>
</blockquote>
<ol start="229">
<li>说明</li>
</ol>
<p>(1) 至少有一个形参，第一个形参用于绑定类，一般命名为’cls’</p>
<p>(2) 使用@classmethod修饰的目的是调用类方法时可以隐式传递类。</p>
<p>(3) 类方法中不能访问实例成员，实例方法中可以访问类成员。</p>
<ol start="230">
<li>作用：操作类变量。</li>
</ol>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ol start="231">
<li>语法</li>
</ol>
<p> (1) 定义：</p>
<blockquote>
<p>@staticmethod</p>
</blockquote>
<p>def 方法名称(参数列表):</p>
<p>方法体</p>
<p>(2) 调用：类名.方法名(参数列表)</p>
<blockquote>
<p>不建议通过对象访问静态方法</p>
</blockquote>
<ol start="232">
<li>说明</li>
</ol>
<blockquote>
<p>(1) 使用@ staticmethod修饰的目的是该方法不需要隐式传参数。</p>
</blockquote>
<p>(2) 静态方法不能访问实例成员和类成员</p>
<ol start="233">
<li>作用：定义常用的工具函数。</li>
</ol>
<h2 id="三大特征"><a href="#三大特征" class="headerlink" title="三大特征"></a>三大特征</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><img src="/pictures/07python_basic/%E5%B0%81%E8%A3%85%E6%80%9D%E6%83%B3.jpg" alt="封装思想"></p>
<h4 id="数据角度讲"><a href="#数据角度讲" class="headerlink" title="数据角度讲"></a>数据角度讲</h4><ol start="234">
<li>定义：</li>
</ol>
<blockquote>
<p>将一些基本数据类型复合成一个自定义类型。</p>
</blockquote>
<ol start="235">
<li>优势：</li>
</ol>
<p>将数据与对数据的操作相关联。</p>
<p>代码可读性更高（类是对象的模板）。</p>
<h4 id="行为角度讲"><a href="#行为角度讲" class="headerlink" title="行为角度讲"></a>行为角度讲</h4><ol start="236">
<li>定义：</li>
</ol>
<blockquote>
<p>类外提供必要的功能，隐藏实现的细节。</p>
</blockquote>
<ol start="237">
<li>优势：</li>
</ol>
<blockquote>
<p>简化编程，使用者不必了解具体的实现细节，只需要调用对外提供的功能。</p>
</blockquote>
<ol start="238">
<li>私有成员：</li>
</ol>
<p> </p>
<p>(1) 作用：无需向类外提供的成员，可以通过私有化进行屏蔽。</p>
<p>(2) 做法：命名使用双下划线开头。</p>
<p>(3) 本质：障眼法，实际也可以访问。</p>
<blockquote>
<p>私有成员的名称被修改为：_类名__成员名，可以通过_dict_属性或dir函数查看。</p>
</blockquote>
<ol start="239">
<li>属性@property：</li>
</ol>
<blockquote>
<p>公开的实例变量，缺少逻辑验证。私有的实例变量与两个公开的方法相结合，又使调用者的操作略显复杂。而属性可以将两个方法的使用方式像操作变量一样方便。</p>
</blockquote>
<p>(1) 定义：</p>
<blockquote>
<p>@property</p>
</blockquote>
<p>def 属性名(self):</p>
<p>return self.__属性名</p>
<p>@属性名.setter</p>
<p>def 属性名(self, value):</p>
<p>self.__属性名&#x3D; value</p>
<p>(2) 调用：</p>
<blockquote>
<p>对象.属性名 &#x3D; 数据</p>
</blockquote>
<p>变量 &#x3D; 对象.属性名</p>
<p>(3) 说明：</p>
<blockquote>
<p>通常两个公开的属性，保护一个私有的变量。</p>
</blockquote>
<p>@property 负责读取，@属性名.setter 负责写入</p>
<p>只写：属性名&#x3D; property(None, 写入方法名)</p>
<h4 id="设计角度讲"><a href="#设计角度讲" class="headerlink" title="设计角度讲"></a>设计角度讲</h4><ol start="240">
<li>定义：</li>
</ol>
<p>(1) 分而治之</p>
<blockquote>
<p>将一个大的需求分解为许多类，每个类处理一个独立的功能。</p>
</blockquote>
<p>(2) 变则疏之</p>
<blockquote>
<p>变化的地方独立封装，避免影响其他类。</p>
</blockquote>
<p>(3) 高 内 聚</p>
<blockquote>
<p>类中各个方法都在完成一项任务(单一职责的类)。</p>
</blockquote>
<p>(4) 低 耦 合</p>
<blockquote>
<p>类与类的关联性与依赖度要低(每个类独立)，让一个类的改变，尽少影响其他类。</p>
</blockquote>
<ol start="241">
<li>优势：</li>
</ol>
<p>便于分工，便于复用，可扩展性强。</p>
<h4 id="案例-信息管理系统"><a href="#案例-信息管理系统" class="headerlink" title="案例:信息管理系统"></a>案例:信息管理系统</h4><p><img src="/pictures/07python_basic/image-20230103161103514.png" alt="image-20230103161103514"></p>
<h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>实现对学生信息的增加、删除、修改和查询。</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><blockquote>
<p>界面可能使用控制台，也可能使用Web等等。</p>
</blockquote>
<ol start="242">
<li><p>识别对象：界面视图类 逻辑控制类 数据模型类</p>
</li>
<li><p>分配职责：</p>
</li>
</ol>
<blockquote>
<p>界面视图类：负责处理界面逻辑，比如显示菜单，获取输入，显示结果等。</p>
</blockquote>
<p>逻辑控制类：负责存储学生信息，处理业务逻辑。比如添加、删除等</p>
<p>数据模型类：定义需要处理的数据类型。比如学生信息。</p>
<ol start="244">
<li>建立交互：</li>
</ol>
<blockquote>
<p>界面视图对象 &lt;—-&gt; 数据模型对象 &lt;—-&gt; 逻辑控制对象</p>
</blockquote>
<h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><p>数据模型类：StudentModel</p>
<p>数据：编号 id,姓名 name,年龄 age,成绩 score</p>
<p>逻辑控制类：StudentManagerController</p>
<p>数据：学生列表 __stu_list</p>
<p>行为：获取列表 stu_list,添加学生 add_student，删除学生remove_student，修改学生update_student，根据成绩排序order_by_score。</p>
<p>界面视图类：StudentManagerView</p>
<p>数据：逻辑控制对象__manager</p>
<p>行为：显示菜单__display_menu，选择菜单项__select_menu_item，入口逻辑main，</p>
<p>输入学生__input_students，输出学生__output_students，删除学生__delete_student，修改学生信息__modify_student</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><img src="/pictures/07python_basic/%E7%BB%A7%E6%89%BF%E5%85%BC%E5%AE%B9%E6%80%A7.jpg" alt="继承兼容性"></p>
<p><img src="/pictures/07python_basic/%E7%BB%A7%E6%89%BF%E5%86%85%E5%AD%98%E5%9B%BE.jpg" alt="继承内存图"></p>
<h4 id="语法角度讲"><a href="#语法角度讲" class="headerlink" title="语法角度讲"></a>语法角度讲</h4><h4 id="继承方法"><a href="#继承方法" class="headerlink" title="继承方法"></a>继承方法</h4><ol start="245">
<li>代码:</li>
</ol>
<blockquote>
<p>class 父类:</p>
</blockquote>
<p>def 父类方法(self):</p>
<p>方法体</p>
<p>class 子类(父类)：</p>
<p>def 子类方法(self):</p>
<p>方法体</p>
<p>儿子 &#x3D; 子类()</p>
<p>儿子.子类方法()</p>
<p>儿子.父类方法()</p>
<ol start="246">
<li>说明：</li>
</ol>
<blockquote>
<p>子类直接拥有父类的方法.</p>
</blockquote>
<h4 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h4><blockquote>
<p>isinstance(对象, 类型)</p>
</blockquote>
<p>返回指定对象是否是某个类的对象。</p>
<p>issubclass(类型，类型)</p>
<p>返回指定类型是否属于某个类型。</p>
<h4 id="继承数据"><a href="#继承数据" class="headerlink" title="继承数据"></a>继承数据</h4><ol start="247">
<li><strong>代码</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">子类</span>(<span class="title class_ inherited__">父类</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,参数列表</span>):</span><br><span class="line">    <span class="built_in">super</span>().__init__(参数列表)</span><br><span class="line">    self.自身实例变量 = 参数</span><br></pre></td></tr></table></figure>

<ol start="248">
<li><strong>说明</strong></li>
</ol>
<blockquote>
</blockquote>
<ul>
<li>子类如果没有构造函数，将自动执行父类的；</li>
</ul>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">class Student(Person):</span><br><span class="line">    # 子类若没有构造函数，使用父类的.</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">s01 = Student()</span><br><span class="line">print(s01.name)</span><br></pre></td></tr></table></figure>

<blockquote>
</blockquote>
<ul>
<li>但如果有构造函数将覆盖父类的,此时必须通过super()函数调用父类的构造函数，以确保父类实例变量被正常创建。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">        self.name = name </span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="comment"># 子类若具有构造函数，则必须先调用父类构造函数。</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,score</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name)  <span class="comment"># 这里调用父类的构造函数，同时需要传参的哦</span></span><br><span class="line">        self.score = score</span><br><span class="line"><span class="comment"># 实例化测试</span></span><br><span class="line">p01 = Person(<span class="string">&quot;李四&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(p01.name)</span><br><span class="line">s01 = Student(<span class="string">&quot;张三&quot;</span>, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(s01.score)</span><br><span class="line"><span class="built_in">print</span>(s01.name)</span><br></pre></td></tr></table></figure>

<h4 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h4><blockquote>
<p>重用现有类的功能，并在此基础上进行扩展。</p>
</blockquote>
<p>说明：子类直接具有父类的成员（共性），还可以扩展新功能。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>一种代码复用的方式。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>耦合度高：父类的变化，直接影响子类。</li>
</ul>
<h4 id="设计角度讲-1"><a href="#设计角度讲-1" class="headerlink" title="设计角度讲"></a>设计角度讲</h4><h4 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h4><blockquote>
<p>将相关类的共性进行抽象，统一概念，隔离变化。</p>
</blockquote>
<h4 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h4><ul>
<li>多个类在概念上是一致的，且需要进行统一的处理。</li>
</ul>
<h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><ul>
<li><p>父类（基类、超类）、子类（派生类）。</p>
</li>
<li><p>父类相对于子类更抽象，范围更宽泛；子类相对于父类更具体，范围更狭小。</p>
</li>
<li><p>单继承：父类只有一个（例如 Java，C#）。</p>
</li>
<li><p>多继承：父类有多个（例如C++，Python）。</p>
</li>
<li><p>Object类：任何类都直接或间接继承自 object 类。</p>
</li>
</ul>
<h4 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h4><p>一个子类继承两个或两个以上的基类，父类中的属性和方法同时被子类继承下来。</p>
<p>同名方法的解析顺序（MRO， Method Resolution Order）:</p>
<p>类自身 –&gt; 父类继承列表（由左至右）–&gt; 再上层父类</p>
<p>A</p>
<p>&#x2F; \</p>
<p>&#x2F; \</p>
<p>B C</p>
<p>\ &#x2F;</p>
<p>\ &#x2F;</p>
<p>D</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    多继承 -- 语法</span></span><br><span class="line"><span class="string">    同名方法解析顺序：MRO</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">m01</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;A - m01&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">m01</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;B - m01&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">m01</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;C - m01&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B,C):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">m02</span>(<span class="params">self</span>):</span><br><span class="line">        self.m01()</span><br><span class="line"></span><br><span class="line">d01 = D()</span><br><span class="line">d01.m02()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(D.mro())<span class="comment"># [D, B,C, A,object]</span></span><br></pre></td></tr></table></figure>

<h4 id="继承练习01"><a href="#继承练习01" class="headerlink" title="继承练习01"></a>继承练习01</h4><p><strong>设计</strong></p>
<ul>
<li><p>存在变化点的内容，不能直接调，而是要抽象一个父类出来；</p>
</li>
<li><p>隔离不变和变化的内容；</p>
</li>
<li><p>父类就是来约束子类规范的，如果按照运行来说，不写父类也是可以的，子类都写一个相同的方法也都可以满足，但是还是要用继承来规范代码编写，所以在父类中可以加一句是否继承父类的校验： <code>if not isinstance(damage_target, Damageable):     raise ValueError(&quot;不是Damageable的子类&quot;)</code></p>
</li>
<li><p>父类如果有的方法，必须要子类也需要有，那就可以在父类中约定抛个异常来约定子类一定要实现重写这个父类方法：   <code>def damage(self, value):如果子类不重写，则异常。        raise NotImplementedError()</code>  这里的主要原理就是，如果子类没有写父类规定的类，那在实际调用这个子类的这个方法的时候，实际是会去找父类的方法，而此时一旦找到了父类的这个方法就知道这个子类肯定是没重写这个方法的，因为就可以报错了。</p>
<p><img src="/pictures/07python_basic/%E6%89%8B%E9%9B%B7%E7%88%86%E7%82%B8.jpg" alt="手雷爆炸"></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    手雷炸了，可能伤害敌人/玩家的生命.</span></span><br><span class="line"><span class="string">             还可能伤害未知事物(鸭子.房子....)</span></span><br><span class="line"><span class="string">    要求：增加了新事物，不影响手雷。</span></span><br><span class="line"><span class="string">    体会：继承的作用</span></span><br><span class="line"><span class="string">         多态的体现</span></span><br><span class="line"><span class="string">         设计原则</span></span><br><span class="line"><span class="string">            开闭原则</span></span><br><span class="line"><span class="string">            单一职责</span></span><br><span class="line"><span class="string">            依赖倒置</span></span><br><span class="line"><span class="string">    画出设计图</span></span><br><span class="line"><span class="string">    15:35</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Granade</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, atk</span>):</span><br><span class="line">        self.atk = atk</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">explode</span>(<span class="params">self, damage_target</span>):</span><br><span class="line">        <span class="comment"># 如果传入的不是子类，则报错.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(damage_target, Damageable):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;不是Damageable的子类&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;爆炸&quot;</span>)</span><br><span class="line">        <span class="comment"># 多态:</span></span><br><span class="line">        <span class="comment"># 调用父类代表(玩家/敌人.....)的可以受伤者.</span></span><br><span class="line">        <span class="comment"># 执类行子(具体玩家/敌人.....)</span></span><br><span class="line">        damage_target.damage(self.atk)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Damageable</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        可以受伤</span></span><br><span class="line"><span class="string">        继承:统一多个子类的概念，隔离变化。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">damage</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="comment"># 如果子类不重写，则异常。</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"><span class="comment"># ------------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span>(<span class="title class_ inherited__">Damageable</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, hp</span>):</span><br><span class="line">        self.hp = hp</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">damage</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.hp -= value</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;玩家受伤啦&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;碎屏&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Enemy</span>(<span class="title class_ inherited__">Damageable</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, hp</span>):</span><br><span class="line">        self.hp = hp</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">damage2</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.hp -= value</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;敌人受伤喽&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;头顶爆字&quot;</span>)</span><br><span class="line"></span><br><span class="line">g01 = Granade(<span class="number">100</span>)</span><br><span class="line">e01 = Enemy(<span class="number">200</span>)</span><br><span class="line">p01 = Player(<span class="number">300</span>)</span><br><span class="line">g01.explode(p01)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="继承练习02"><a href="#继承练习02" class="headerlink" title="继承练习02"></a>继承练习02</h4><ul>
<li><p>子类的差异化问题子类自己解决，可以通过子类的构造方法来提供参数；</p>
</li>
<li><p>差异化的部分，不能找父类去要。</p>
<p><img src="/pictures/07python_basic/%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%90%86%E5%99%A8.jpg" alt="图形管理器"></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    定义图形管理器类</span></span><br><span class="line"><span class="string">        1. 管理所有图形</span></span><br><span class="line"><span class="string">        2. 提供计算所有图形总面积的方法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    具体图形:</span></span><br><span class="line"><span class="string">        圆形(pi × r ** 2)</span></span><br><span class="line"><span class="string">        矩形(长*宽)</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    测试：</span></span><br><span class="line"><span class="string">        创建1个圆形对象，1个矩形对象，添加到图形管理器中.</span></span><br><span class="line"><span class="string">        调用图形管理器的计算面积方法，输出结果。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    要求：增加新图形，不修改图形管理器的代码.</span></span><br><span class="line"><span class="string">    体会：面向对象三大特征：</span></span><br><span class="line"><span class="string">            封装/继承/多态</span></span><br><span class="line"><span class="string">         面向对象设计原则：</span></span><br><span class="line"><span class="string">            开闭/单一/倒置</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphicManager</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__graphics = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_graphic</span>(<span class="params">self, graphic</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(graphic, Graphic):</span><br><span class="line">            self.__graphics.append(graphic)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_total_area</span>(<span class="params">self</span>):</span><br><span class="line">        total_area = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 遍历图形列表，累加每个图形的面积</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self.__graphics:</span><br><span class="line">            <span class="comment"># 多态：</span></span><br><span class="line">            <span class="comment"># 调用的是图形</span></span><br><span class="line">            <span class="comment"># 执行的是圆形/矩形...</span></span><br><span class="line">            total_area += item.calculate_area()</span><br><span class="line">        <span class="keyword">return</span> total_area</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graphic</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate_area</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 如果子类不重写，则异常.</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"><span class="comment">#-----------------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>(<span class="title class_ inherited__">Graphic</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,radius</span>):</span><br><span class="line">        self.radius = radius</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate_area</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * self.radius **<span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectanlge</span>(<span class="title class_ inherited__">Graphic</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,length,width</span>):</span><br><span class="line">        self.lenght = length</span><br><span class="line">        self.width = width</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate_area</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.lenght *  self.width</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c01 = Circle(<span class="number">5</span>)</span><br><span class="line">r01 = Rectanlge(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">manager = GraphicManager()</span><br><span class="line">manager.add_graphic(c01)</span><br><span class="line">manager.add_graphic(r01)</span><br><span class="line">re = manager.get_total_area()</span><br><span class="line"><span class="built_in">print</span>(re)</span><br></pre></td></tr></table></figure>

<h4 id="继承练习03"><a href="#继承练习03" class="headerlink" title="继承练习03"></a>继承练习03</h4><p><img src="/pictures/07python_basic/%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E5%99%A8.jpg" alt="员工管理器"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    定义员工管理器</span></span><br><span class="line"><span class="string">        1.管理所有员工</span></span><br><span class="line"><span class="string">        2. 计算所有员工工资</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    员工：</span></span><br><span class="line"><span class="string">        程序员：底薪 + 项目分红</span></span><br><span class="line"><span class="string">        销售：底薪 + 销售额 * 0.05</span></span><br><span class="line"><span class="string">        软件测试...</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    要求：增加新岗位，员工管理器不变.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmployeeManager</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__employees = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_employee</span>(<span class="params">self, emp</span>):</span><br><span class="line">        self.__employees.append(emp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_total_saraly</span>(<span class="params">self</span>):</span><br><span class="line">        total_saraly = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self.__employees:</span><br><span class="line">            <span class="comment"># 调用是抽象的员工类</span></span><br><span class="line">            <span class="comment"># 执行是具体的员工(程序员/销售..)</span></span><br><span class="line">            total_saraly += item.calculate_salary()</span><br><span class="line">        <span class="keyword">return</span> total_saraly</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, base_salary</span>):</span><br><span class="line">        self.base_salary = base_salary</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate_salary</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.base_salary</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Programmer</span>(<span class="title class_ inherited__">Employee</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, base_salary, bonus</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(base_salary)</span><br><span class="line">        self.bonus = bonus</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate_salary</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># return self.base_salary + self.bonus</span></span><br><span class="line">        <span class="comment"># 扩展重写</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().calculate_salary()+ self.bonus</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Salesmen</span>(<span class="title class_ inherited__">Employee</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, base_salary, sale_value</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(base_salary)</span><br><span class="line">        self.sale_value = sale_value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate_salary</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.base_salary + self.sale_value * <span class="number">0.05</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">manager = EmployeeManager()</span><br><span class="line">manager.add_employee(Programmer(<span class="number">200000</span>,<span class="number">500</span>))</span><br><span class="line">manager.add_employee(Salesmen(<span class="number">2000</span>,<span class="number">1000</span>))</span><br><span class="line"><span class="built_in">print</span>(manager.get_total_saraly())</span><br></pre></td></tr></table></figure>

<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="设计角度讲-2"><a href="#设计角度讲-2" class="headerlink" title="设计角度讲"></a>设计角度讲</h4><h4 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h4><blockquote>
<p>父类的同一种动作或者行为，在不同的子类上有不同的实现。</p>
</blockquote>
<h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><ol start="249">
<li><p>在继承的基础上，体现类型的个性化（一个行为有不同的实现）。</p>
</li>
<li><p>增强程序扩展性，体现开闭原则。</p>
</li>
</ol>
<h4 id="语法角度讲-1"><a href="#语法角度讲-1" class="headerlink" title="语法角度讲"></a>语法角度讲</h4><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><ul>
<li><p>子类实现了父类中相同的方法（方法名、参数）。</p>
</li>
<li><p>在调用该方法时，实际执行的是子类的方法。调用父，执行子。</p>
</li>
</ul>
<h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><p>Ctrl + O</p>
<h4 id="内置可重写函数"><a href="#内置可重写函数" class="headerlink" title="内置可重写函数"></a>内置可重写函数</h4><p>Python中，以双下划线开头、双下划线结尾的是系统定义的成员。我们可以在自定义类中进行重写，从而改变其行为。</p>
<h4 id="转换字符串"><a href="#转换字符串" class="headerlink" title="转换字符串"></a>转换字符串</h4><p>__str__函数：将对象转换为字符串(对人友好的)</p>
<p>__repr__函数：将对象转换为字符串(解释器可识别的)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    内置可重写函数</span></span><br><span class="line"><span class="string">    练习:exercise01.py</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StudentModel</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name=<span class="string">&quot;&quot;</span>, age=<span class="number">0</span>, score=<span class="number">0</span>, <span class="built_in">id</span>=<span class="number">0</span></span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.score = score</span><br><span class="line">        self.<span class="built_in">id</span> = <span class="built_in">id</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对象 --&gt; 字符串 (随意格式)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我叫%s,编号是%d,年龄是%d,成绩是:%d&quot;</span>%(self.name,self.<span class="built_in">id</span>,self.age,self.score)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对象 --&gt; 字符串(解释器可识别,有格式)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;StudentModel(&#x27;%s&#x27;,%d,%d,%d)&quot;</span>%(self.name,self.age,self.score,self.<span class="built_in">id</span>)</span><br><span class="line"></span><br><span class="line">s01 = StudentModel(<span class="string">&quot;无忌&quot;</span>,<span class="number">27</span>,<span class="number">100</span>,<span class="number">101</span>)</span><br><span class="line">str01 = <span class="built_in">str</span>(s01)</span><br><span class="line"><span class="built_in">print</span>(str01)</span><br><span class="line"><span class="built_in">print</span>(s01)</span><br><span class="line"></span><br><span class="line">str02 =<span class="built_in">repr</span>(s01)</span><br><span class="line"><span class="built_in">print</span>(str02)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据字符串执行python代码</span></span><br><span class="line">re = <span class="built_in">eval</span>(<span class="string">&quot;1+2*5&quot;</span>)</span><br><span class="line"><span class="comment"># exec</span></span><br><span class="line"><span class="built_in">print</span>(re)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 克隆对象</span></span><br><span class="line"><span class="comment"># repr 返回python格式的字符串</span></span><br><span class="line"><span class="comment"># eval根据字符串执行代码</span></span><br><span class="line">s02 = <span class="built_in">eval</span>(<span class="built_in">repr</span>(s01))   <span class="comment">#  通过eval 配合repr（对象）来克隆一个对象</span></span><br><span class="line">s02.name = <span class="string">&quot;老张&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s01.name)</span><br></pre></td></tr></table></figure>

<h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><p>定义：让自定义的类生成的对象(实例)能够使用运算符进行操作。</p>
<h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h4><p><img src="/pictures/07python_basic/image-20230103161655636.png" alt="image-20230103161655636"></p>
<h4 id="反向算数运算符重载"><a href="#反向算数运算符重载" class="headerlink" title="反向算数运算符重载"></a>反向算数运算符重载</h4><p><img src="/pictures/07python_basic/image-20230103161740574.png" alt="image-20230103161740574"></p>
<h4 id="复合运算符重载"><a href="#复合运算符重载" class="headerlink" title="复合运算符重载"></a>复合运算符重载</h4><p><img src="/pictures/07python_basic/image-20230103161614116.png" alt="image-20230103161614116"></p>
<blockquote>
<p>运算符重载的内容实际使用的很少，平常可能不会用，但是要知道有这个东西。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    运算符重载</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector1</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.x = x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;一维向量的分量是：&quot;</span> + <span class="built_in">str</span>(self.x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> Vector1(self.x + other)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__radd__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> Vector1(self.x + other)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iadd__</span>(<span class="params">self, other</span>):</span><br><span class="line">        self.x += other</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">v01 = Vector1(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(v01 + <span class="number">2</span>)  <span class="comment"># v01.__add__(2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 练习:实现自定义类的对象与数值的减法，乘法运算。</span></span><br><span class="line"><span class="comment"># 略...</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span> + v01)</span><br><span class="line"><span class="comment"># 练习:实现数值与自定义类的对象的减法，乘法运算。</span></span><br><span class="line"><span class="comment"># 略...</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(v01))</span><br><span class="line"><span class="comment"># 重写__iadd__，实现在原对象基础上的变化。</span></span><br><span class="line"><span class="comment"># 如果重写__iadd__,默认使用__add__，一般会产生新对象.</span></span><br><span class="line">v01 += <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(v01,<span class="built_in">id</span>(v01))</span><br><span class="line"></span><br><span class="line"><span class="comment"># list01 = [1]</span></span><br><span class="line"><span class="comment"># print(id(list01))</span></span><br><span class="line"><span class="comment"># # 生成新对象</span></span><br><span class="line"><span class="comment"># re = list01 + [2]</span></span><br><span class="line"><span class="comment"># print(re,id(re))</span></span><br><span class="line"><span class="comment"># # 在原有对象基础上，累加.</span></span><br><span class="line"><span class="comment"># list01 += [2]</span></span><br><span class="line"><span class="comment"># print(list01,id(list01))</span></span><br></pre></td></tr></table></figure>

<h4 id="比较运算重载"><a href="#比较运算重载" class="headerlink" title="比较运算重载"></a>比较运算重载</h4><p><img src="/pictures/07python_basic/image-20230103161555646.png" alt="image-20230103161555646"></p>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h3 id="开-闭原则（目标、总的指导思想）"><a href="#开-闭原则（目标、总的指导思想）" class="headerlink" title="开-闭原则（目标、总的指导思想）"></a>开-闭原则（目标、总的指导思想）</h3><p><strong>O</strong>pen <strong>C</strong>losed <strong>P</strong>rinciple</p>
<ul>
<li><p>对扩展开放，对修改关闭。</p>
</li>
<li><p><strong>增加新功能，不改变原有代码</strong>。允许增加新功能，但是不能改变原来代码这就是开闭原则</p>
</li>
</ul>
<h3 id="类的单一职责（一个类的定义）"><a href="#类的单一职责（一个类的定义）" class="headerlink" title="类的单一职责（一个类的定义）"></a>类的单一职责（一个类的定义）</h3><p><strong>S</strong>ingle <strong>R</strong>esponsibility <strong>P</strong>rinciple</p>
<ul>
<li><p>一个类有且只有一个改变它的原因；发生变化的原因只能是一个那就是遵循了这个原则。</p>
</li>
<li><p>一个类只做一件事情；</p>
</li>
</ul>
<h3 id="依赖倒置（依赖抽象）"><a href="#依赖倒置（依赖抽象）" class="headerlink" title="依赖倒置（依赖抽象）"></a>依赖倒置（依赖抽象）</h3><p><strong>D</strong>ependency <strong>I</strong>nversion <strong>P</strong>rinciple</p>
<ul>
<li><p>客户端代码(调用的类)尽量依赖(使用)抽象。就是使用者，调用的这个类就是客户端代码，抽象就是不具体的，就是父类，子类更具体，父类更抽象，父类就是把各个子类抽象一下。是先有子类，然后再抽象出父类，调类的时候，是调用父类，调用抽象类这样就能够实现更加稳定的逻辑。</p>
</li>
<li><p>抽象不应该依赖细节，细节应该依赖抽象。</p>
</li>
<li><p>父类约束子类在行为上保持一致</p>
<p><img src="/pictures/07python_basic/%E8%80%81%E5%BC%A0%E5%8E%BB%E4%B8%9C%E5%8C%97%E8%AE%BE%E8%AE%A101.jpg" alt="老张去东北设计01"></p>
<p><img src="/pictures/07python_basic/%E8%80%81%E5%BC%A0%E5%8E%BB%E4%B8%9C%E5%8C%97%E8%AE%BE%E8%AE%A102.jpg" alt="老张去东北设计02"></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    继承 -- 设计(2)</span></span><br><span class="line"><span class="string">    练习:exercise03.py</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 需求：老张开车去东北</span></span><br><span class="line"><span class="comment"># 变化：    坐飞机</span></span><br><span class="line"><span class="comment">#          坐火车</span></span><br><span class="line"><span class="comment">#          骑车</span></span><br><span class="line"><span class="comment">#          ...</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        交通工具,代表所有具体的交通工具(火车/飞机..)</span></span><br><span class="line"><span class="string">        继承：隔离子类变化,将子类的共性(坐/飞..)提取到父类(运输)中.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">transport</span>(<span class="params">self, str_position</span>):</span><br><span class="line">        <span class="comment"># 因为父类太过于抽象，所以写不出方法体,那就直接采用pass,这个价值就是约束子类要有这个行为。</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端代码，用交通工具。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">go_to</span>(<span class="params">self, vehicle, str_position</span>):</span><br><span class="line">        <span class="comment"># 多态：调用父，执行子.</span></span><br><span class="line">        <span class="comment"># 调用的是交通工具的运输方法</span></span><br><span class="line">        <span class="comment"># 执行的是飞机的运输方法或者汽车的运输方法</span></span><br><span class="line">        vehicle.transport(str_position)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -------以上是架构师完成的--以下是程序员完成的-----</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>(<span class="title class_ inherited__">Vehicle</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">transport</span>(<span class="params">self, str_position</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;汽车开到&quot;</span>, str_position)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Airplane</span>(<span class="title class_ inherited__">Vehicle</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">transport</span>(<span class="params">self, str_position</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;飞机飞到&quot;</span>, str_position)</span><br><span class="line"></span><br><span class="line">p01 = Person(<span class="string">&quot;老张&quot;</span>)</span><br><span class="line">c01 = Car()</span><br><span class="line">a01 = Airplane()</span><br><span class="line">p01.go_to(c01, <span class="string">&quot;东北&quot;</span>)</span><br><span class="line">p01.go_to(a01, <span class="string">&quot;东北&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="组合复用原则（复用的最佳实践）"><a href="#组合复用原则（复用的最佳实践）" class="headerlink" title="组合复用原则（复用的最佳实践）"></a>组合复用原则（复用的最佳实践）</h3><p>Composite Reuse Principle</p>
<ul>
<li><p>如果仅仅为了代码复用优先选择组合复用，而非继承复用。</p>
</li>
<li><p>组合的耦合性相对继承低。</p>
</li>
<li><p>组合更加灵活，下面第一个图中，如果使用继承，那就成了人是手机，实际上是一种组合关系，人有一个手机；</p>
</li>
</ul>
<p><img src="/pictures/07python_basic/%E7%BB%84%E5%90%88%E5%A4%8D%E7%94%A8.jpg" alt="组合复用"></p>
<h3 id="里氏替换（继承后的重写，指导继承的设计）"><a href="#里氏替换（继承后的重写，指导继承的设计）" class="headerlink" title="里氏替换（继承后的重写，指导继承的设计）"></a>里氏替换（继承后的重写，指导继承的设计）</h3><p><strong>L</strong>iskov <strong>S</strong>ubstitution <strong>P</strong>rinciple</p>
<p>父类出现的地方可以被子类替换，在替换后依然保持原功能。</p>
<p>子类要拥有父类的所有功能。</p>
<p>子类在重写父类方法时，尽量选择扩展重写，防止改变了功能。– 下面第46行就是扩展重写，使用父类中已经有的类容再做扩展即可，而不是子类自己又重新写一个。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    10:50 上课</span></span><br><span class="line"><span class="string">    定义员工管理器</span></span><br><span class="line"><span class="string">        1.管理所有员工</span></span><br><span class="line"><span class="string">        2. 计算所有员工工资</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    员工：</span></span><br><span class="line"><span class="string">        程序员：底薪 + 项目分红</span></span><br><span class="line"><span class="string">        销售：底薪 + 销售额 * 0.05</span></span><br><span class="line"><span class="string">        软件测试...</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    要求：增加新岗位，员工管理器不变.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmployeeManager</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__employees = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_employee</span>(<span class="params">self, emp</span>):</span><br><span class="line">        self.__employees.append(emp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_total_saraly</span>(<span class="params">self</span>):</span><br><span class="line">        total_saraly = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self.__employees:</span><br><span class="line">            <span class="comment"># 调用是抽象的员工类</span></span><br><span class="line">            <span class="comment"># 执行是具体的员工(程序员/销售..)</span></span><br><span class="line">            total_saraly += item.calculate_salary()</span><br><span class="line">        <span class="keyword">return</span> total_saraly</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, base_salary</span>):</span><br><span class="line">        self.base_salary = base_salary</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate_salary</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.base_salary</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Programmer</span>(<span class="title class_ inherited__">Employee</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, base_salary, bonus</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(base_salary)</span><br><span class="line">        self.bonus = bonus</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate_salary</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># return self.base_salary + self.bonus</span></span><br><span class="line">        <span class="comment"># 扩展重写</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().calculate_salary()+ self.bonus</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Salesmen</span>(<span class="title class_ inherited__">Employee</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, base_salary, sale_value</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(base_salary)</span><br><span class="line">        self.sale_value = sale_value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate_salary</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.base_salary + self.sale_value * <span class="number">0.05</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">manager = EmployeeManager()</span><br><span class="line">manager.add_employee(Programmer(<span class="number">200000</span>,<span class="number">500</span>))</span><br><span class="line">manager.add_employee(Salesmen(<span class="number">2000</span>,<span class="number">1000</span>))</span><br><span class="line"><span class="built_in">print</span>(manager.get_total_saraly())</span><br></pre></td></tr></table></figure>

<h3 id="迪米特法则（类与类交互的原则）"><a href="#迪米特法则（类与类交互的原则）" class="headerlink" title="迪米特法则（类与类交互的原则）"></a>迪米特法则（类与类交互的原则）</h3><p>Law of Demeter</p>
<p>不要和陌生人说话。</p>
<p>类与类交互时，在满足功能要求的基础上，传递的数据量越少越好。因为这样可能降低耦合度。–要调用其他类的时候，如果只使用几个方法，那就只调用其中的这几个方法即可，这样就可以先抽象一下，抽象一个父类出来，当然，这种情况也可能出现过度设计。</p>
<h3 id="综合练习"><a href="#综合练习" class="headerlink" title="综合练习"></a>综合练习</h3><h4 id="需求信息"><a href="#需求信息" class="headerlink" title="需求信息"></a>需求信息</h4><table>
<thead>
<tr>
<th>职业</th>
<th>名称</th>
<th>分类</th>
<th>法力消耗</th>
<th>冷却</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>少林</td>
<td>少林普攻</td>
<td>瞬发技能</td>
<td>无</td>
<td>无</td>
<td>攻击单个近身敌人，对目标每秒造成100%外功攻击伤害。自动连续攻击</td>
</tr>
<tr>
<td>少林</td>
<td>罗汉棍</td>
<td>瞬发技能</td>
<td>10法力</td>
<td>2秒</td>
<td>达摩祖师所创棍法，刚猛无敌。攻击单个近身敌人，对目标造成200%外功攻击伤害</td>
</tr>
<tr>
<td>少林</td>
<td>摩诃无量</td>
<td>瞬发技能</td>
<td>50法力</td>
<td>8秒</td>
<td>少林七十二绝技之一，瞬间缩短和敌手的距离。像旋风一样挥舞武器，攻击以自身为中心半径4码范围内 的所有敌人，对每个目标造成每秒217%的外功攻击伤害。攻击持续3.9秒。</td>
</tr>
<tr>
<td>少林</td>
<td>迦叶功</td>
<td>瞬发技能</td>
<td>20法力</td>
<td>5秒</td>
<td>少林七十二绝技之一，以一条齐眉棍幻出千万棍影。向单个敌人冲锋并进行凶猛攻击，对目标造成150%外功攻击伤害</td>
</tr>
<tr>
<td>少林</td>
<td>韦陀杵</td>
<td>瞬发技能</td>
<td>20法力</td>
<td>10秒</td>
<td>少林七十二绝技之一，与大力金刚掌齐名，以浑厚内力重创敌人。重击地面，使4码内所有敌人防御降低10%，并眩晕，持续2.5秒。</td>
</tr>
<tr>
<td>少林</td>
<td>金钟罩</td>
<td>瞬发技能</td>
<td>20法力</td>
<td>15秒</td>
<td>少林七十二绝技之一，以丹田之气发出狮吼震慑敌人胆魄。开启盾墙，所有敌人对自身造成的伤害减免20%，持续10秒。</td>
</tr>
<tr>
<td>少林</td>
<td>狮吼功</td>
<td>瞬发技能</td>
<td>40法力</td>
<td>20秒</td>
<td>少林七十二绝技之一，刀枪不入。吼叫，嘲讽你附近8码范围内所有敌人，持续5秒。使你和附近8码内所有队友攻击提升15%，持续10秒。并使附近8码内所有敌人伤害降低10%，持续5秒。</td>
</tr>
<tr>
<td>少林</td>
<td>金刚伏魔</td>
<td>瞬发技能</td>
<td>100%战意</td>
<td>20秒</td>
<td>以易筋经催动少林绝技的终极奥义嘲讽全屏范围内所有敌人，挥舞武器攻击地，对全屏范围内所有敌人造成100%血上限伤害。对BOSS和PVP战斗无效。</td>
</tr>
<tr>
<td>逍遥</td>
<td>逍遥普攻</td>
<td>瞬发技能</td>
<td></td>
<td></td>
<td>攻击6码范围内的单个敌人，对目标每秒造成100%内功攻击伤害。自动连续攻击</td>
</tr>
<tr>
<td>逍遥</td>
<td>小无相功</td>
<td>瞬发技能</td>
<td>10法力</td>
<td>2秒</td>
<td>逍遥派无上内功，鸠摩智曾以此内功催发出少林绝技拈花指来骗取六脉神剑释放电弧，击中敌人造 成200%的内功攻击伤害。</td>
</tr>
<tr>
<td>逍遥</td>
<td>祝融掌</td>
<td>瞬发技能</td>
<td></td>
<td></td>
<td>祝融掌：出自庄子“逍遥游”，将敌方的内力化掉，并转化吸收内力汇聚于气海。喷射一条火焰攻击敌人， 每击造成每秒300%的内功攻击伤害，持续3.9秒。并使命中目标减速30%，持续3秒。</td>
</tr>
<tr>
<td>逍遥</td>
<td>北冥神功</td>
<td>瞬发技能</td>
<td></td>
<td></td>
<td>北冥神功：李秋水除白虹掌力的另一绝学，将内力汇聚一点急剧升温后劈出。对单个目标造成120%的内功攻击 伤害，并使敌人冻结3秒</td>
</tr>
<tr>
<td>逍遥</td>
<td>寒霜怒雪</td>
<td>瞬发技能</td>
<td></td>
<td></td>
<td>：以易经八八六十四卦为基础。按特定顺序方位进行，步法飘忽灵动。天降寒冰轰击目标区域范围内 所有敌人，造成每秒125%的内功攻击伤害，持续5秒。并使命中目标减速80%，持续5秒</td>
</tr>
<tr>
<td>逍遥</td>
<td>凌波微步</td>
<td>瞬发技能</td>
<td></td>
<td></td>
<td>：内力凝出的冰甲，聪哑老人苏星河曾靠此招躲过丁春秋的化功大法。将你瞬间传送到前方7码的目标位置</td>
</tr>
<tr>
<td>逍遥</td>
<td>毁天灭地</td>
<td>瞬发技能</td>
<td></td>
<td></td>
<td>：凝聚北冥真气释放的终极招式嘲讽全屏范围内所有敌人，召唤一颗巨大的陨石从天而降，引起全屏 范围内地面灼烧，对全屏范围内所有敌人造成100%血上限伤害。对BOSS和PVP战斗无效</td>
</tr>
<tr>
<td>丐帮</td>
<td>丐帮普攻</td>
<td>瞬发技能</td>
<td>无</td>
<td>0秒</td>
<td>攻击单个近身敌人，每秒造成100%内功攻击伤害，自动连续攻击</td>
</tr>
<tr>
<td>丐帮</td>
<td>飞龙在天</td>
<td>瞬发技能</td>
<td>100战意</td>
<td>20秒</td>
<td>降龙十八掌第二式，跃起半空，居高下击，威力奇大，嘲讽全屏范围内所有敌人，造成等同于其生命上限的伤 害，对BOSS和玩家无效</td>
</tr>
<tr>
<td>丐帮</td>
<td>神龙摆尾</td>
<td>瞬发技能</td>
<td>10法力</td>
<td>2秒</td>
<td>降龙十八掌第十八式，劲道奇猛，无所不辞，攻击单个近身敌人，立即造成200%内功攻击伤害，触发“御龙” 效果，使自身暴击率提升5%，持续6秒，“御龙”效果最多可叠加3次</td>
</tr>
<tr>
<td>丐帮</td>
<td>天下无狗</td>
<td>瞬发技能</td>
<td>50法力</td>
<td>8秒</td>
<td>打狗棒法的最精妙招式，八方皆棒，劲力甚广，挥动武器攻击4次，每击都会对前方5步半圆内所有敌人施加 “打狗”效果，“打狗”会在3秒内持续造成总共270%内功攻击伤害，并减速50%持续3秒</td>
</tr>
<tr>
<td>丐帮</td>
<td>醉饮江湖</td>
<td>瞬发技能</td>
<td>20法力</td>
<td>5秒</td>
<td>气运丹田，以雄厚内力将烈酒逼出，控人心窍，眩晕7步范围内单个敌人1秒，将其迅速拉至面前</td>
</tr>
<tr>
<td>丐帮</td>
<td>擒龙控鹤</td>
<td>瞬发技能</td>
<td>20法力</td>
<td>10秒</td>
<td>丐帮秘传擒拿功夫，使人失去反击之力，迷惑4步范围内所有敌人，使其无法使用技能，持续2.5秒</td>
</tr>
<tr>
<td>丐帮</td>
<td>密云不雨</td>
<td>瞬发技能</td>
<td>20法力</td>
<td>15秒</td>
<td>降龙十八掌第十三式，韬光养晦，弃攻击而全力守御，将自身50%攻击转化为防御，持续3秒</td>
</tr>
<tr>
<td>丐帮</td>
<td>亢龙有悔</td>
<td>瞬发技能</td>
<td>40法力</td>
<td>20秒</td>
<td>降龙十八掌第十一式，从至刚之中生出至柔，有余不尽，震击5步范围内所有敌人，持续造成每秒200%内功功击伤害，持续5秒</td>
</tr>
</tbody></table>
<h4 id="设计图"><a href="#设计图" class="headerlink" title="设计图"></a>设计图</h4><p>可能首先想到的是下面这种方式：（不妥当）</p>
<p>换一种思路：</p>
<ul>
<li><p>文件的变化不影响功能；</p>
</li>
<li><p>新增新技能不修改代码；</p>
</li>
<li><p>某个算法改变，只修改某个类，其他类不受影响；</p>
</li>
</ul>
<p><img src="/pictures/07python_basic/%E6%8A%80%E8%83%BD%E7%B3%BB%E7%BB%9F.jpg" alt="技能系统"></p>
<h4 id="编码-1"><a href="#编码-1" class="headerlink" title="编码"></a>编码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    技能系统</span></span><br><span class="line"><span class="string">    练习:指出下列代码哪里体现了三大特征/六大原则。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    三大特征：</span></span><br><span class="line"><span class="string">        封装：将每种影响效果单独做成类.</span></span><br><span class="line"><span class="string">        继承：将各种影响效果抽象为SkillImpactEffect</span></span><br><span class="line"><span class="string">              隔离技能释放器与各种影响效果的变化。</span></span><br><span class="line"><span class="string">        多态：各种影响效果在重写SkillImpactEffect类中impact方法.</span></span><br><span class="line"><span class="string">             释放器调用SkillImpactEffect执行各种效果。</span></span><br><span class="line"><span class="string">    六大原则：</span></span><br><span class="line"><span class="string">        开闭原则：增加新(技能/影响效果)，不修改释放器代码.</span></span><br><span class="line"><span class="string">        单一职责：SkillImpactEffect 负责 隔离变化</span></span><br><span class="line"><span class="string">                 DamageEffect.. 负责定义具体的效果</span></span><br><span class="line"><span class="string">                 SkillDeployer 负责释放技能</span></span><br><span class="line"><span class="string">        依赖倒置：(1)释放器没有调用具体影响效果，而是调用SkillImpactEffect。</span></span><br><span class="line"><span class="string">                (2)抽象的不依赖于具体的。</span></span><br><span class="line"><span class="string">                  具体做法：释放器通过&quot;依赖注入&quot;(读取配置文件，创建影响效果对象),</span></span><br><span class="line"><span class="string">                          使释放器不依赖具体影响效果.</span></span><br><span class="line"><span class="string">        组合复用：释放器与影响效果是组合关系.</span></span><br><span class="line"><span class="string">                可以灵活的选择各种影响效果。</span></span><br><span class="line"><span class="string">        里氏替换：(1)父类出现的地方可以被子类替换</span></span><br><span class="line"><span class="string">                 释放器存储影响效果列表,实际可以将各种子类存入进来.</span></span><br><span class="line"><span class="string">        迪米特法则：所有类之间的耦合度都很低.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SkillImpactEffect</span>:  <span class="comment"># 负责 隔离变化</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        技能影响效果</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">impact</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DamageEffect</span>(<span class="title class_ inherited__">SkillImpactEffect</span>): <span class="comment">#负责定义具体的效果</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        伤害生命效果</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">impact</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;扣你%d血&quot;</span> % self.value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LowerDeffenseEffect</span>(<span class="title class_ inherited__">SkillImpactEffect</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        降低防御力</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value, time</span>):</span><br><span class="line">        self.value = value</span><br><span class="line">        self.time = time</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">impact</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;降低%d防御力,持续%d秒&quot;</span> % (self.value, self.time))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DizzinessEffect</span>(<span class="title class_ inherited__">SkillImpactEffect</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        眩晕</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, time</span>):</span><br><span class="line">        self.time = time</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">impact</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;眩晕%d秒&quot;</span> % self.time)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SkillDeployer</span>: <span class="comment">#负责释放技能</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        技能释放器</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="comment"># 加载配置文件 &#123;技能名称:[效果1,效果2...],...&#125;</span></span><br><span class="line">        self.__dict_skill_config = self.__load_config_file()</span><br><span class="line">        <span class="comment"># 创建效果对象</span></span><br><span class="line">        self.__effect_objects = self.__create_effect_objects()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__load_config_file</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 加载文件.....</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">&quot;降龙十八掌&quot;</span>: [<span class="string">&quot;DamageEffect(200)&quot;</span>, <span class="string">&quot;LowerDeffenseEffect(-10,5)&quot;</span>, <span class="string">&quot;DizzinessEffect(6)&quot;</span>],</span><br><span class="line">            <span class="string">&quot;六脉神剑&quot;</span>: [<span class="string">&quot;DamageEffect(100)&quot;</span>, <span class="string">&quot;DizzinessEffect(6)&quot;</span>]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__create_effect_objects</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 根据name创建相应的技能对象</span></span><br><span class="line">        <span class="comment">#    降龙十八掌 -&gt; [&quot;技能1&quot;，&quot;技能2&quot;]</span></span><br><span class="line">        list_effect_name = self.__dict_skill_config[self.name]</span><br><span class="line">        list_effect_object = []</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> list_effect_name:</span><br><span class="line">            <span class="comment"># &quot;技能1&quot; --&gt; 技能1的对象</span></span><br><span class="line">            <span class="comment"># 对象 = eval(&quot;DamageEffect(200)&quot;)</span></span><br><span class="line">            effect_object = <span class="built_in">eval</span>(item)</span><br><span class="line">            list_effect_object.append(effect_object)</span><br><span class="line">        <span class="keyword">return</span> list_effect_object</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成技能(执行效果)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate_skill</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name, <span class="string">&quot;技能释放啦&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self.__effect_objects:</span><br><span class="line">            <span class="comment"># 调用父类，执行子类.</span></span><br><span class="line">            item.impact()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xlsbz = SkillDeployer(<span class="string">&quot;降龙十八掌&quot;</span>)</span><br><span class="line">xlsbz.generate_skill()</span><br><span class="line"></span><br><span class="line">lmsj = SkillDeployer(<span class="string">&quot;六脉神剑&quot;</span>)</span><br><span class="line">lmsj.generate_skill()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h1><h2 id="模块-Module"><a href="#模块-Module" class="headerlink" title="模块 Module"></a>模块 Module</h2><h3 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>包含一系列数据、函数、类的文件，通常以.py结尾。</p>
</blockquote>
<h3 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h3><blockquote>
<p>让一些相关的数据，函数，类有逻辑的组织在一起，使逻辑结构更加清晰。</p>
</blockquote>
<p>有利于多人合作开发。</p>
<h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><h4 id="import"><a href="#import" class="headerlink" title="import"></a><code>import</code></h4><ol>
<li>语法：</li>
</ol>
<blockquote>
<p>import 模块名</p>
</blockquote>
<p>import 模块名 as 别名</p>
<ol start="2">
<li><p>作用：将某模块整体导入到当前模块中</p>
</li>
<li><p>使用：模块名.成员</p>
</li>
</ol>
<h4 id="from-import"><a href="#from-import" class="headerlink" title="from import"></a><code>from import</code></h4><ol start="4">
<li>语法：</li>
</ol>
<blockquote>
<p>from 模块名 import 成员名[ as 别名1]</p>
</blockquote>
<ol start="5">
<li><p>作用：将模块内的一个或多个成员导入到当前模块的作用域中。</p>
</li>
<li><p>使用：直接使用成员名</p>
</li>
</ol>
<h4 id="from-import-1"><a href="#from-import-1" class="headerlink" title="from import \*"></a><code>from import \*</code></h4><ol start="7">
<li><p>语法：from 模块名 import *</p>
</li>
<li><p>作用：将某模块的所有成员导入到当前模块。</p>
</li>
<li><p><strong>模块中以下划线(_)开头的属性，不会被导入，通常称这些成员为隐藏成员。</strong>–直接通过import  * 的时候就不会导入隐藏成员，但是通过from  XX import _func   这种是可以的，毕竟你指名道姓就要用这个，也是可以的。</p>
</li>
<li><p><strong>需要注意，导入进来的成员不要和当前模块中的成员冲突</strong>，也要防止与其他模块之间冲突，如果有冲突的也可以用as来定义别名</p>
</li>
</ol>
<h3 id="模块变量"><a href="#模块变量" class="headerlink" title="模块变量"></a>模块变量</h3><p>**__all__变量：定义可导出成员，仅对from xx import <em>语句有效。</em>*</p>
<p>__doc__变量：文档字符串。</p>
<p>__file__变量：模块对应的文件路径名。</p>
<p><strong>__name__变量：模块自身名字，可以判断是否为主模块。</strong></p>
<p>当此模块作为主模块(第一个运行的模块)运行时，__name__绑定’<strong>main</strong>‘，不是主模块，而是被其它模块导入时,存储模块名。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    模块相关概念</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># from module01 import *</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># fun01()</span></span><br><span class="line"><span class="comment"># # 1. 隐藏成员，不能通过from 模块 import × 形式导入</span></span><br><span class="line"><span class="comment"># _fun02()</span></span><br><span class="line"><span class="comment"># from module01 import _fun02</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># # 隐藏成员，可以通过其他形式调用</span></span><br><span class="line"><span class="comment"># _fun02()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 通过__all__指定可导出成员</span></span><br><span class="line"><span class="keyword">from</span> module01 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">MyClass.fun03()</span><br><span class="line">_fun02()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.可以通过该属性，查看文档注释</span></span><br><span class="line"><span class="built_in">print</span>(__doc__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.返回当前模块的绝对路径（从系统根目录开始计算的）</span></span><br><span class="line"><span class="built_in">print</span>(__file__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.</span></span><br><span class="line"><span class="comment"># 现象：</span></span><br><span class="line"><span class="comment"># 主模块叫做：__main__</span></span><br><span class="line"><span class="comment"># 非主模块叫做：真名</span></span><br><span class="line"><span class="built_in">print</span>(__name__)</span><br><span class="line"><span class="comment"># 作用1： 不是主模块不执行。(测试代码)</span></span><br><span class="line"><span class="comment"># 作用2： 只有是主模块才执行。(主模块代码)</span></span><br><span class="line"><span class="comment"># 使用：</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h3 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h3><blockquote>
<p>在模块导入时，模块的所有语句会执行。</p>
</blockquote>
<p>如果一个模块已经导入，则再次导入时不会重新执行模块内的语句。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol start="11">
<li><p>内置模块(builtins)，在解析器的内部可以直接使用。</p>
</li>
<li><p>标准库模块，安装Python时已安装且可直接使用。</p>
</li>
<li><p>第三方模块（通常为开源），需要自己安装。</p>
</li>
<li><p>用户自己编写的模块（可以作为其他人的第三方模块）</p>
</li>
</ol>
<h2 id="包package"><a href="#包package" class="headerlink" title="包package"></a>包package</h2><h3 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h3><p>将模块以文件夹的形式进行分组管理。</p>
<h3 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h3><blockquote>
<p>让一些相关的模块组织在一起，使逻辑结构更加清晰。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    包</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">python程序结构</span></span><br><span class="line"><span class="string">    文件夹  ---- 项目根目录</span></span><br><span class="line"><span class="string">        包</span></span><br><span class="line"><span class="string">            模块</span></span><br><span class="line"><span class="string">                类</span></span><br><span class="line"><span class="string">                    函数</span></span><br><span class="line"><span class="string">                        语句</span></span><br><span class="line"><span class="string">    练习：my_project</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # form 包.模块 import 成员</span></span><br><span class="line"><span class="comment"># from package01.module_a import fun01</span></span><br><span class="line"><span class="comment"># fun01()</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># form 包.包.模块 import 成员</span></span><br><span class="line"><span class="keyword">from</span> package01.package02.module_b <span class="keyword">import</span> fun02</span><br><span class="line">fun02()</span><br><span class="line"></span><br><span class="line"><span class="comment"># import package01.module_a as pm</span></span><br><span class="line"><span class="comment"># pm.fun01()</span></span><br></pre></td></tr></table></figure>

<h3 id="导入-1"><a href="#导入-1" class="headerlink" title="导入"></a>导入</h3><blockquote>
<p>import 包名.模块名 [as 模块新名]</p>
</blockquote>
<p>import 包名.子包名.模块名 [as 模块新名]</p>
<p>from 包名 import 模块名 [as 模块新名]</p>
<p>from 包名.子包名 import 模块名 [as 模块新名]</p>
<p>from 包名.子包名.模块名 import 成员名 [as 属性新名]</p>
<h1 id="导入包内的所有子包和模块"><a href="#导入包内的所有子包和模块" class="headerlink" title="导入包内的所有子包和模块"></a>导入包内的所有子包和模块</h1><p>from 包名 import *</p>
<p>from 包名.模块名 import *</p>
<h3 id="init-py-文件"><a href="#init-py-文件" class="headerlink" title="init.py 文件"></a><strong>init</strong>.py 文件</h3><blockquote>
<p>是包内必须存在的文件</p>
</blockquote>
<p>会在包加载时被自动调用</p>
<h4 id="all"><a href="#all" class="headerlink" title="all"></a><strong>all</strong></h4><p>记录from 包 import * 语句需要导入的模块</p>
<p>案例：</p>
<ol start="15">
<li>根据下列结构，创建包与模块。</li>
</ol>
<blockquote>
<p>my_ project &#x2F;</p>
</blockquote>
<p>main.py</p>
<p>common&#x2F;</p>
<p><strong>init</strong>.py</p>
<p>list_helper.py</p>
<p>skill_system&#x2F;</p>
<p><strong>init</strong>.py</p>
<p>skill_deployer.py</p>
<p>skill_manager.py</p>
<ol start="16">
<li><p>在main.py中调用skill_manager.py中实例方法。</p>
</li>
<li><p>在skill_manager.py中调用skill_deployer.py中实例方法。</p>
</li>
<li><p>在skill_deployer.py中调用list_helper.py中类方法。</p>
</li>
</ol>
<h3 id="搜索顺序"><a href="#搜索顺序" class="headerlink" title="搜索顺序"></a>搜索顺序</h3><blockquote>
<p>内置模块</p>
</blockquote>
<p>sys.path 提供的路径</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;common -- list_helper&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># 如果不再pycharm中运行当前模块，则导包失败.</span></span><br><span class="line"><span class="comment"># 将项目根目录加入path中，导包才会成功.</span></span><br><span class="line">sys.path.append(<span class="string">&quot;/home/tarena/1905/month01/code/day15/my_project&quot;</span>)  <span class="comment"># 在导包失败的时候，可以手动添加项目根目录添加到路径列表中</span></span><br><span class="line"><span class="built_in">print</span>(sys.path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> main <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">main_fun01()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="异常处理Error"><a href="#异常处理Error" class="headerlink" title="异常处理Error"></a>异常处理Error</h1><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ol start="19">
<li><p>定义：运行时检测到的错误。</p>
</li>
<li><p>现象：当异常发生时，程序不会再向下执行，而转到函数的调用语句。</p>
</li>
<li><p>常见异常类型：</p>
</li>
</ol>
<blockquote>
<p>– 名称异常(NameError)：变量未定义。</p>
</blockquote>
<p>– 类型异常(TypeError)：不同类型数据进行运算。</p>
<p>– 索引异常(IndexError)：超出索引范围。</p>
<p>– 属性异常(AttributeError)：对象没有对应名称的属性。</p>
<p>– 键异常(KeyError)：没有对应名称的键。</p>
<p>– 为实现异常(NotImplementedError)：尚未实现的方法。</p>
<p>– 异常基类Exception。</p>
<h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2><ol start="22">
<li>语法：</li>
</ol>
<blockquote>
<p>try:</p>
</blockquote>
<p>可能触发异常的语句</p>
<p>except 错误类型1 [as 变量1]：</p>
<p>处理语句1</p>
<p>except 错误类型2 [as 变量2]：</p>
<p>处理语句2</p>
<p>except Exception [as 变量3]：</p>
<p>不是以上错误类型的处理语句</p>
<p>else:</p>
<p>未发生异常的语句</p>
<p>finally:</p>
<p>无论是否发生异常的语句</p>
<ol start="23">
<li><p>作用：将程序由异常状态转为正常流程。</p>
</li>
<li><p>说明：</p>
</li>
</ol>
<blockquote>
<p>as 子句是用于绑定错误对象的变量，可以省略</p>
</blockquote>
<p>except子句可以有一个或多个，用来捕获某种类型的错误。</p>
<p>else子句最多只能有一个。</p>
<p>finally子句最多只能有一个，如果没有except子句，必须存在。</p>
<p>如果异常没有被捕获到，会向上层(调用处)继续传递，直到程序终止运行。</p>
<h2 id="raise-语句"><a href="#raise-语句" class="headerlink" title="raise 语句"></a>raise 语句</h2><ol start="25">
<li><p>作用：抛出一个错误，让程序进入异常状态。</p>
</li>
<li><p>目的：在程序调用层数较深时，向主调函数传递错误信息要层层return 比较麻烦，所以人为抛出异常，可以直接传递错误信息。。</p>
</li>
</ol>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><ol start="27">
<li>定义：</li>
</ol>
<blockquote>
<p>class 类名Error(Exception):</p>
</blockquote>
<p>def <strong>init</strong>(self,参数):</p>
<p>super().<strong>init</strong>(参数)</p>
<p>self.数据 &#x3D; 参数</p>
<ol start="28">
<li>调用：</li>
</ol>
<blockquote>
<p>try:</p>
</blockquote>
<p>….</p>
<p>raise 自定义异常类名(参数)</p>
<p>….</p>
<p>except 定义异常类 as 变量名:</p>
<p>变量名.数据</p>
<ol start="29">
<li>作用：封装错误信息</li>
</ol>
<h4 id="综合使用异常处理练习："><a href="#综合使用异常处理练习：" class="headerlink" title="综合使用异常处理练习："></a>综合使用异常处理练习：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    界面代码</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> bll <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> model <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StudentManagerView</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    学生管理器视图</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__manager = StudentManagerController()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__display_menu</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;1)添加学生&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;2)显示学生&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;3)删除学生&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;4)修改学生&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;5)按照成绩升序显示学生&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__select_menu</span>(<span class="params">self</span>):</span><br><span class="line">        item = <span class="built_in">input</span>(<span class="string">&quot;请输入：&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">            self.__input_student()</span><br><span class="line">        <span class="keyword">elif</span> item == <span class="string">&quot;2&quot;</span>:</span><br><span class="line">            self.__output_students(self.__manager.stu_list)</span><br><span class="line">        <span class="keyword">elif</span> item == <span class="string">&quot;3&quot;</span>:</span><br><span class="line">            self.__delete_student()</span><br><span class="line">        <span class="keyword">elif</span> item == <span class="string">&quot;4&quot;</span>:</span><br><span class="line">            self.__modify_student()</span><br><span class="line">        <span class="keyword">elif</span> item == <span class="string">&quot;5&quot;</span>:</span><br><span class="line">            self.__output_student_by_score()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            界面视图入口</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            self.__display_menu()</span><br><span class="line">            self.__select_menu()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__input_number</span>(<span class="params">self,message</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                number = <span class="built_in">int</span>(<span class="built_in">input</span>(message))</span><br><span class="line">                <span class="keyword">return</span> number</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;输入有误&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__input_student</span>(<span class="params">self</span>):</span><br><span class="line">        name = <span class="built_in">input</span>(<span class="string">&quot;请输入姓名：&quot;</span>)</span><br><span class="line">        <span class="comment"># age = int(input(&quot;请输入年龄：&quot;))</span></span><br><span class="line">        <span class="comment"># score = int(input(&quot;请输入成绩：&quot;))</span></span><br><span class="line">        age = self.__input_number(<span class="string">&quot;请输入年龄：&quot;</span>)</span><br><span class="line">        score = self.__input_number(<span class="string">&quot;请输入成绩：&quot;</span>)</span><br><span class="line">        stu = StudentModel(name, age, score)</span><br><span class="line">        self.__manager.add_student(stu)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__output_students</span>(<span class="params">self, list_output</span>):</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> list_output:</span><br><span class="line">            <span class="built_in">print</span>(item.<span class="built_in">id</span>, item.name, item.atk, item.score)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delete_student</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># id = int(input(&quot;请输入编号：&quot;))</span></span><br><span class="line">        <span class="built_in">id</span> = self.__input_number(<span class="string">&quot;请输入编号：&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.__manager.remove_student(<span class="built_in">id</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;删除成功&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;删除失败&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__modify_student</span>(<span class="params">self</span>):</span><br><span class="line">        stu = StudentModel()</span><br><span class="line">        <span class="comment"># stu.id = int(input(&quot;请输入需要修改的学生编号:&quot;))</span></span><br><span class="line">        stu.<span class="built_in">id</span> = self.__input_number(<span class="string">&quot;请输入需要修改的学生编号:&quot;</span>)</span><br><span class="line">        stu.name = <span class="built_in">input</span>(<span class="string">&quot;请输入新的学生名称：&quot;</span>)</span><br><span class="line">        <span class="comment"># stu.atk = int(input(&quot;请输入新的学生年龄：&quot;))</span></span><br><span class="line">        <span class="comment"># stu.score = int(input(&quot;请输入新的学生成绩：&quot;))</span></span><br><span class="line">        stu.atk = self.__input_number(<span class="string">&quot;请输入新的学生年龄:&quot;</span>)</span><br><span class="line">        stu.score = self.__input_number(<span class="string">&quot;请输入新的学生成绩：&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.__manager.update_student(stu):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;修改成功&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;修改失败&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__output_student_by_score</span>(<span class="params">self</span>):</span><br><span class="line">        self.__manager.order_by_score()</span><br><span class="line">        self.__output_students(self.__manager.stu_list)</span><br></pre></td></tr></table></figure>

<h1 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h1><p>每一次对过程的重复称为一次”迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值。例如：循环获取容器中的元素。</p>
<h2 id="可迭代对象iterable"><a href="#可迭代对象iterable" class="headerlink" title="可迭代对象iterable"></a>可迭代对象iterable</h2><ol start="30">
<li><p>定义：具有__iter__函数的对象，可以返回迭代器对象。</p>
</li>
<li><p>语法</p>
</li>
</ol>
<blockquote>
<p>– 创建：</p>
</blockquote>
<p>class 可迭代对象名称:</p>
<p>  def <strong>iter</strong>(self):</p>
<p>      return 迭代器</p>
<p>– 使用：</p>
<p>for 变量名 in 可迭代对象:</p>
<p>语句</p>
<ol start="32">
<li>原理：</li>
</ol>
<blockquote>
<p>迭代器 &#x3D; 可迭代对象.<strong>iter</strong>()</p>
</blockquote>
<p>while True:</p>
<p>try:</p>
<p>print(迭代器.<strong>next</strong>())</p>
<p>except StopIteration:</p>
<p>break</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 练习2:不使用for，获取字典所有数据。</span></span><br><span class="line"><span class="comment">#  &#123;&quot;铁扇公主&quot;:101,&quot;铁锤公主&quot;:102,“扳手王子”:103&#125;</span></span><br><span class="line"><span class="comment"># 10:40</span></span><br><span class="line"></span><br><span class="line">dict01 = &#123;<span class="string">&quot;铁扇公主&quot;</span>: <span class="number">101</span>, <span class="string">&quot;铁锤公主&quot;</span>: <span class="number">102</span>, <span class="string">&quot;扳手王子&quot;</span>: <span class="number">103</span>&#125;</span><br><span class="line"></span><br><span class="line">iterator = dict01.__iter__()  <span class="comment"># 存的就是迭代器，迭代器就有__next__ 方法</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        key = iterator.__next__()</span><br><span class="line">        <span class="built_in">print</span>(key, dict01[key])</span><br><span class="line">    <span class="keyword">except</span> StopIteration:  <span class="comment"># 取不到为止，就会抛出StopIteration异常，所以捕获后退出循环即可</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h2 id="迭代器对象iterator"><a href="#迭代器对象iterator" class="headerlink" title="迭代器对象iterator"></a>迭代器对象iterator</h2><ol start="33">
<li><p>定义：可以被next()函数调用并返回下一个值的对象。</p>
</li>
<li><p>语法</p>
</li>
</ol>
<blockquote>
<p>class 迭代器类名:</p>
</blockquote>
<p>def <strong>init</strong>(self, 聚合对象):</p>
<p>self.<strong>聚合对象</strong>&#x3D; 聚合对象</p>
<p>def <strong>next</strong>(self):</p>
<p>if 没有元素:</p>
<p>raise StopIteration</p>
<p>return 聚合对象元素</p>
<p><img src="/pictures/07python_basic/%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3.jpg" alt="迭代器设计思想"></p>
<p>手写迭代器对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    迭代器</span></span><br><span class="line"><span class="string">    练习:exercise03.py</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Skill</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SkillManager</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        技能管理器  可迭代对象</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__skills = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_skill</span>(<span class="params">self, skill</span>):</span><br><span class="line">        self.__skills.append(skill)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 创建一个迭代器对象,并传递需要迭代的数据。</span></span><br><span class="line">        <span class="keyword">return</span> SkillIterator(self.__skills)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SkillIterator</span>:  <span class="comment"># 创建一个迭代器，其需要有一个__next__方法和一个取值到最后抛出异常的一个方法</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        技能迭代器</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, target</span>):</span><br><span class="line">        self.__target = target</span><br><span class="line">        self.__index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 如果没有数据了，则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> self.__index &gt; <span class="built_in">len</span>(self.__target) - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回下一个数据</span></span><br><span class="line">        temp = self.__target[self.__index]</span><br><span class="line">        self.__index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line">manager = SkillManager()</span><br><span class="line">manager.add_skill(Skill())</span><br><span class="line">manager.add_skill(Skill())</span><br><span class="line">manager.add_skill(Skill())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> manager:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line">iterator = manager.__iter__()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        item = iterator.__next__()</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>图形迭代器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 练习：图形管理器记录多个图形</span></span><br><span class="line"><span class="comment">#      迭代图形管理器对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graphic</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphicManager</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        图形管理器，可迭代对象(参与for)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__graphics = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_graphic</span>(<span class="params">self, graphic</span>):</span><br><span class="line">        self.__graphics.append(graphic)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> GraphicIterator(self.__graphics)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphicIterator</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        图形迭代器（获取下一个数据）</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, target</span>):</span><br><span class="line">        self.__target = target</span><br><span class="line">        self.__index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.__index &gt; <span class="built_in">len</span>(self.__target) - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        temp = self.__target[self.__index]</span><br><span class="line">        self.__index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> temp</span><br><span class="line">manager = GraphicManager()</span><br><span class="line">manager.add_graphic(Graphic())</span><br><span class="line">manager.add_graphic(Graphic())</span><br><span class="line">manager.add_graphic(Graphic())</span><br><span class="line"><span class="comment"># for item in manager:</span></span><br><span class="line"><span class="comment">#     print(item)</span></span><br><span class="line">iterator = manager.__iter__()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        item = iterator.__next__()</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<ol start="35">
<li>说明：</li>
</ol>
<blockquote>
<p>– 聚合对象通常是容器对象。</p>
</blockquote>
<ol start="4">
<li>作用：使用者只需通过一种方式，便可简洁明了的获取聚合对象中各个元素，而又无需了解其内部结构。</li>
</ol>
<h1 id="生成器generator"><a href="#生成器generator" class="headerlink" title="生成器generator"></a>生成器generator</h1><ol start="36">
<li><p>定义：能够动态(循环一次计算一次返回一次)提供数据的可迭代对象。</p>
</li>
<li><p>作用：在循环过程中，按照某种算法推算数据，不必创建容器存储完整的结果，从而节省内存空间。数据量越大，优势越明显。</p>
</li>
<li><p>以上作用也称之为<strong>延迟操作或惰性操作</strong>，通俗的讲就是在需要的时候才计算结果，而不是一次构建出所有结果。</p>
</li>
</ol>
<h2 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h2><ol start="39">
<li><p>定义：含有<strong>yield</strong>语句的函数，返回值为生成器对象。– 生成器&#x3D;可迭代对象+迭代器</p>
</li>
<li><p>语法</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建：</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>():</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">yield</span> 数据</span><br><span class="line">            ...</span><br><span class="line"><span class="comment"># 调用：</span></span><br><span class="line"><span class="keyword">for</span> 变量名 <span class="keyword">in</span> 函数名():</span><br><span class="line">        语句</span><br></pre></td></tr></table></figure>

<ol start="41">
<li>说明：</li>
</ol>
<blockquote>
<p>– 调用生成器函数将返回一个生成器对象，不执行函数体。</p>
</blockquote>
<p>– yield翻译为”产生”或”生成”</p>
<ol start="42">
<li>执行过程：</li>
</ol>
<p> (1) 调用生成器函数会自动创建迭代器对象。</p>
<p>(2) 调用迭代器对象的__next__()方法时才执行生成器函数。</p>
<p>(3) 每次执行到yield语句时返回数据，暂时离开。</p>
<p>(4) 待下次调用__next__()方法时继续从离开处继续执行。</p>
<p> 原理：生成迭代器对象的大致规则如下</p>
<blockquote>
<p>– 将yield关键字以前的代码放在next方法中。</p>
</blockquote>
<ul>
<li>以后在需要拿到多个同类对象的时候，可以使用yield来处理</li>
</ul>
<p>– 将yield关键字后面的数据作为next方法的返回值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    yield --&gt; 生成器</span></span><br><span class="line"><span class="string">    练习:exercise07.py</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">class MyRange:</span></span><br><span class="line"><span class="string">    def __init__(self, stop_value):</span></span><br><span class="line"><span class="string">        self.stop_value = stop_value</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def __iter__(self):</span></span><br><span class="line"><span class="string">        number = 0</span></span><br><span class="line"><span class="string">        while number &lt; self.stop_value:</span></span><br><span class="line"><span class="string">            yield number</span></span><br><span class="line"><span class="string">            number += 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">my01 = MyRange(10)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">iterator = my01.__iter__()</span></span><br><span class="line"><span class="string">while True:</span></span><br><span class="line"><span class="string">    try:</span></span><br><span class="line"><span class="string">        item = iterator.__next__()</span></span><br><span class="line"><span class="string">        print(item)</span></span><br><span class="line"><span class="string">    except StopIteration:</span></span><br><span class="line"><span class="string">        break</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># 生成器原理</span></span><br><span class="line"><span class="string">class MyGenerator:</span></span><br><span class="line"><span class="string">    # 生成器 = 可迭代对象 + 迭代器</span></span><br><span class="line"><span class="string">    def __init__(self,stop_value):</span></span><br><span class="line"><span class="string">        self.begin = 0</span></span><br><span class="line"><span class="string">        self.stop_value = stop_value</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    def __iter__(self):</span></span><br><span class="line"><span class="string">        return self</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def __next__(self):</span></span><br><span class="line"><span class="string">        if self.begin &gt;= self.stop_value:</span></span><br><span class="line"><span class="string">            raise StopIteration</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">        temp = self.begin</span></span><br><span class="line"><span class="string">        self.begin+=1</span></span><br><span class="line"><span class="string">        return temp</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_range</span>(<span class="params">stop_value</span>):</span><br><span class="line">    number = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> number &lt; stop_value:</span><br><span class="line">        <span class="keyword">yield</span> number</span><br><span class="line">        number += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">my01 = my_range(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(my01), <span class="built_in">dir</span>(my01))<span class="comment"># dir 获取对象所有成员</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(my01.__iter__()), <span class="built_in">id</span>(my01))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> my01:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure>

<h2 id="内置生成器"><a href="#内置生成器" class="headerlink" title="内置生成器"></a>内置生成器</h2><h3 id="枚举函数enumerate"><a href="#枚举函数enumerate" class="headerlink" title="枚举函数enumerate"></a>枚举函数enumerate</h3><ol start="44">
<li>语法：</li>
</ol>
<blockquote>
<p>for 变量 in enumerate(可迭代对象):</p>
</blockquote>
<p>语句</p>
<p>for 索引, 元素in enumerate(可迭代对象):</p>
<p>语句</p>
<ol start="45">
<li>作用：遍历可迭代对象时，可以将索引与元素组合为一个元组。</li>
</ol>
<h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><ol start="46">
<li>语法：</li>
</ol>
<blockquote>
<p>for item in zip(可迭代对象1, 可迭代对象2….):</p>
</blockquote>
<p>语句</p>
<ol start="47">
<li>作用：将多个可迭代对象中对应的元素组合成一个个元组，生成的元组个数由最小的可迭代对象决定。</li>
</ol>
<h2 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h2><ol start="48">
<li><p>定义：用推导式形式创建生成器对象。</p>
</li>
<li><p>语法：变量 &#x3D; ( 表达式 for 变量 in 可迭代对象 [if 真值表达式] )</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 练习:1. 获取列表中所有字符串</span></span><br><span class="line"><span class="comment">#     2. 获取列表中所有小数</span></span><br><span class="line"><span class="comment"># 要求:分别使用生成器函数/生成器表达式/列表推导式完成.</span></span><br><span class="line">list01 = [<span class="number">3</span>, <span class="string">&quot;54&quot;</span>, <span class="literal">True</span>, <span class="number">6</span>, <span class="string">&quot;76&quot;</span>, <span class="number">1.6</span>, <span class="literal">False</span>, <span class="number">3.5</span>]</span><br><span class="line"><span class="comment"># 练习:1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find01</span>():</span><br><span class="line">    <span class="keyword">for</span> itme <span class="keyword">in</span> list01:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(itme) == <span class="built_in">str</span>:</span><br><span class="line">            <span class="keyword">yield</span> itme</span><br><span class="line"></span><br><span class="line">re = find01()</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> re:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line">re = (itme <span class="keyword">for</span> itme <span class="keyword">in</span> list01 <span class="keyword">if</span> <span class="built_in">type</span>(itme) == <span class="built_in">str</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> re:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line">re = [itme <span class="keyword">for</span> itme <span class="keyword">in</span> list01 <span class="keyword">if</span> <span class="built_in">type</span>(itme) == <span class="built_in">str</span>]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> re:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 练习:2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find02</span>():</span><br><span class="line">    <span class="keyword">for</span> itme <span class="keyword">in</span> list01:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(itme) == <span class="built_in">float</span>:</span><br><span class="line">            <span class="keyword">yield</span> itme</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> find02():</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> (item <span class="keyword">for</span> item <span class="keyword">in</span> list01 <span class="keyword">if</span> <span class="built_in">type</span>(item) == <span class="built_in">float</span>):</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> [item <span class="keyword">for</span> item <span class="keyword">in</span> list01 <span class="keyword">if</span> <span class="built_in">type</span>(item) == <span class="built_in">float</span>]:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure>

<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><ol>
<li>定义：用一系列函数解决问题。</li>
</ol>
<blockquote>
<p>– 函数可以赋值给变量，赋值后变量绑定函数。</p>
</blockquote>
<p>– 允许将函数作为参数传入另一个函数。</p>
<p>– 允许函数返回一个函数。</p>
<ol start="2">
<li>高阶函数：将函数作为参数或返回值的函数。</li>
</ol>
<h2 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h2><blockquote>
<p>将核心逻辑传入方法体，使该方法的适用性更广，体现了面向对象的开闭原则。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 1. 使用生成器函数实现以上3个需求</span></span><br><span class="line"><span class="comment"># 2. 体会函数式编程的&quot;封装&quot;</span></span><br><span class="line"><span class="comment">#    将三个函数变化点提取到另外三个函数中.</span></span><br><span class="line"><span class="comment">#    将共性提取到另外一个函数中</span></span><br><span class="line"><span class="comment"># 3. 体会函数式编程的&quot;继承&quot;与&quot;多态&quot;</span></span><br><span class="line"><span class="comment">#    使用变量隔离变化点,在共性函数中调用变量.</span></span><br><span class="line"><span class="comment"># 4. 测试(执行上述功能)</span></span><br><span class="line"></span><br><span class="line">list01 = [<span class="number">43</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">87</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需求1:在列表中查找所有偶数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find01</span>():</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> list01:</span><br><span class="line">        <span class="keyword">if</span> item % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需求2:在列表中查找所有大于10的数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find02</span>():</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> list01:</span><br><span class="line">        <span class="keyword">if</span> item &gt; <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需求3:在列表中查找所有范围在10--50之间的数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find03</span>():</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> list01:</span><br><span class="line">        <span class="keyword">if</span> <span class="number">10</span> &lt; item &lt; <span class="number">50</span>:</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line"></span><br><span class="line"><span class="comment"># &quot;封装&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">condition01</span>(<span class="params">item</span>):</span><br><span class="line">    <span class="keyword">return</span> item % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">condition02</span>(<span class="params">item</span>):</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">condition03</span>(<span class="params">item</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span> &lt; item &lt; <span class="number">50</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &quot;继承&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">func_condition</span>):</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> list01:</span><br><span class="line">        <span class="comment"># &quot;多态&quot;</span></span><br><span class="line">        <span class="comment"># 调用:具体条件的抽象</span></span><br><span class="line">        <span class="comment"># 执行:具体条件的函数</span></span><br><span class="line">        <span class="keyword">if</span> func_condition(item):</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> find(condition02):</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法参数,如果传递10/&quot;张无忌&quot;/True,叫做传递数据</span></span><br><span class="line"><span class="comment"># 方法参数,如果函数1/函数2/函数3,叫做传递逻辑</span></span><br><span class="line"><span class="comment"># 15:35</span></span><br></pre></td></tr></table></figure>

<h3 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h3><ol start="50">
<li><p>定义：是一种匿名方法。</p>
</li>
<li><p>作用：作为参数传递时语法简洁，优雅，代码可读性强。</p>
</li>
</ol>
<blockquote>
<p>随时创建和销毁，减少程序耦合度。</p>
</blockquote>
<ol start="52">
<li>语法</li>
</ol>
<blockquote>
<p>– 定义：</p>
</blockquote>
<p>变量 &#x3D; lambda 形参: 方法体</p>
<p>– 调用：</p>
<p>变量(实参)</p>
<ol start="53">
<li>说明：</li>
</ol>
<blockquote>
<p>– 形参没有可以不填</p>
</blockquote>
<p>– 方法体只能有一条语句，且不支持赋值语句。</p>
<h3 id="内置高阶函数"><a href="#内置高阶函数" class="headerlink" title="内置高阶函数"></a>内置高阶函数</h3><ol start="54">
<li><p>map（函数，可迭代对象）：使用可迭代对象中的每个元素调用函数，将返回值作为新可迭代对象元素；返回值为新可迭代对象。</p>
</li>
<li><p>filter(函数，可迭代对象)：根据条件筛选可迭代对象中的元素，返回值为新可迭代对象。</p>
</li>
<li><p>sorted(可迭代对象，key &#x3D; 函数,reverse &#x3D; bool值)：排序，返回值为排序结果。</p>
</li>
<li><p>max(可迭代对象，key &#x3D; 函数)：根据函数获取可迭代对象的最大值。</p>
</li>
<li><p>min(可迭代对象，key &#x3D; 函数)：根据函数获取可迭代对象的最小值。</p>
</li>
</ol>
<h2 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h2><blockquote>
<p>逻辑连续，当内部函数被调用时，不脱离当前的逻辑。</p>
</blockquote>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ol start="59">
<li>三要素：</li>
</ol>
<blockquote>
<p>– 必须有一个内嵌函数。</p>
</blockquote>
<p>– 内嵌函数必须引用外部函数中变量。</p>
<p>– 外部函数返回值必须是内嵌函数。</p>
<ol start="60">
<li>语法</li>
</ol>
<blockquote>
<p>– 定义：</p>
</blockquote>
<p><img src="/pictures/07python_basic/image.png" alt="image.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">外部函数名</span>(<span class="params">参数</span>):</span><br><span class="line">	外部变量</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">内部函数名</span>(<span class="params">参数</span>):</span><br><span class="line">    使用外部变量</span><br><span class="line">    <span class="keyword">return</span> 内部函数名</span><br></pre></td></tr></table></figure>

<p>– 调用：</p>
<p>变量 &#x3D; 外部函数名(参数)</p>
<p>变量(参数)</p>
<ol start="61">
<li><p>定义：在一个函数内部的函数,同时内部函数又引用了外部函数的变量。</p>
</li>
<li><p>本质：闭包是将内部函数和外部函数的执行环境绑定在一起的对象。</p>
</li>
<li><p>优点：内部函数可以使用外部变量。</p>
</li>
<li><p>缺点：外部变量一直存在于内存中，不会在调用结束后释放，占用内存。</p>
</li>
<li><p>作用：实现python装饰器。</p>
</li>
</ol>
<h3 id="函数装饰器decorator"><a href="#函数装饰器decorator" class="headerlink" title="函数装饰器decorator"></a>函数装饰器decorator</h3><blockquote>
<p>闭包的应用就是装饰器</p>
</blockquote>
<ol start="66">
<li><p>定义：在不改变原函数的调用以及内部代码情况下，为其添加新功能的函数。</p>
</li>
<li><p>语法</p>
</li>
</ol>
<p>def 函数装饰器名称(func):</p>
<p>​		def 内嵌函数(*args, **kwargs):</p>
<p>​				需要添加的新功能</p>
<p>​				return func(*args, **kwargs)</p>
<p>​		return内嵌函数</p>
<p>原函数 &#x3D; 内嵌函数</p>
<blockquote>
<p>@ 函数装饰器名称</p>
</blockquote>
<p>def 原函数名称(参数):</p>
<p>函数体</p>
<p>原函数(参数)</p>
<ol start="68">
<li>本质：使用”@函数装饰器名称”修饰原函数，等同于创建与原函数名称相同的变量，关联内嵌函数；故调用原函数时执行内嵌函数。</li>
</ol>
<p>原函数名称 &#x3D; 函数装饰器名称（原函数名称）</p>
<ol start="69">
<li>装饰器链：</li>
</ol>
<blockquote>
<p>一个函数可以被多个装饰器修饰，执行顺序为从近到远。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    闭包</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun01</span>():</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fun02</span>():</span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="keyword">return</span> fun02</span><br><span class="line"><span class="comment"># 调用外部函数，返回值是内嵌函数</span></span><br><span class="line">result = fun01()</span><br><span class="line"><span class="comment"># 调用内嵌函数</span></span><br><span class="line">result()  <span class="comment"># 可以访问外部变量a</span></span><br><span class="line"><span class="comment"># 闭包应用:逻辑连续，当内部函数被调用时，不脱离当前的逻辑</span></span><br><span class="line"><span class="comment"># 压岁钱</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">give_gife_money</span>(<span class="params">money</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        得到压岁钱</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;得到了%d压岁钱&quot;</span> % money)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">child_buy</span>(<span class="params">target, price</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            孩子购买商品</span></span><br><span class="line"><span class="string">        :param target: 需要购买的商品</span></span><br><span class="line"><span class="string">        :param price: 商品单价</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">nonlocal</span> money</span><br><span class="line">        <span class="keyword">if</span> money &gt;= price:</span><br><span class="line">            money -= price</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;孩子花了%.1f钱，购买了%s&quot;</span> % (price, target))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;钱不够啦&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> child_buy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下列代码是一个连续的逻辑</span></span><br><span class="line">action = give_gife_money(<span class="number">10000</span>)</span><br><span class="line">action(<span class="string">&quot;唐僧肉&quot;</span>, <span class="number">0.5</span>)</span><br><span class="line">action(<span class="string">&quot;小汽车&quot;</span>, <span class="number">2000</span>)</span><br><span class="line">action(<span class="string">&quot;手机&quot;</span>, <span class="number">8000</span>)</span><br></pre></td></tr></table></figure>

</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/python/">python</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2023/01/12/20dynamicpr_countbin1/"><span>前n个数字二进制中 1 的个数</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'false' == 'true';
var verify = 'false' == 'true';
var record_ip = 'false' == 'true';
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  recordIP:record_ip,
  appId:'F1Yvbj0NxwrB3DRaljWZOPe9-gzGzoHsz',
  appKey:'vvI8fXV2CIAJXrex6pBlFHBz',
  placeholder:'留下您的评论建议吧~',
  avatar:'wavatar',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
})</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2023 By babyfengfjx</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script src="/js/search/algolia.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>