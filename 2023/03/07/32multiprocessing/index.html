<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="python并发编程multiprocessing"><meta name="keywords" content="python,并发"><meta name="author" content="babyfengfjx"><meta name="copyright" content="babyfengfjx"><title>python并发编程multiprocessing | babyfengfjx'Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"RPHOC0H5T9","apiKey":"723903e5de5899f6cc4ad96fc50931c1","indexName":"hexo_blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">并发编程概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">2. 进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8D%8F%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">3. 协程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BA%BF%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.3.</span> <span class="toc-text">4. 线程、进程和协程的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%BA%93-asyncio"><span class="toc-number">1.4.</span> <span class="toc-text">异步编程库 asyncio</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%9Amultiprocessing"><span class="toc-number">2.</span> <span class="toc-text">多进程：multiprocessing</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">概念介绍：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.2.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3"><span class="toc-number">2.3.</span> <span class="toc-text">实例讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">2.3.1.</span> <span class="toc-text">模板示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.3.2.</span> <span class="toc-text">实战示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E8%AE%B2%E8%A7%A3"><span class="toc-number">2.4.</span> <span class="toc-text">补充讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pool-starmap-async-%E5%92%8C-pool-map%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">2.4.1.</span> <span class="toc-text">pool.starmap_async 和 pool.map的区别：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8B%E8%BD%BD%E4%BE%8B%E5%AD%90"><span class="toc-number">2.4.2.</span> <span class="toc-text">并发下载例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5I-x2F-O%E6%93%8D%E4%BD%9C%E5%92%8C%E5%BC%82%E6%AD%A5I-x2F-O%E6%93%8D%E4%BD%9C"><span class="toc-number">2.4.3.</span> <span class="toc-text">同步I&#x2F;O操作和异步I&#x2F;O操作</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://github.com/babyfengfjx/babyfengfjx.github.io/blob/main/pictures/avatar/avatar.jpg?raw=true"></div><div class="author-info__name text-center">babyfengfjx</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">38</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">39</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">24</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">babyfengfjx'Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">python并发编程multiprocessing</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-03-07</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/python/">python</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="并发编程概念"><a href="#并发编程概念" class="headerlink" title="并发编程概念"></a>并发编程概念</h2><blockquote>
<p>当我们谈论Python并发编程时，我们通常会涉及到多个库和概念，比如线程、进程、协程等。1. 线程</p>
</blockquote>
<p>在Python中，我们可以使用<code>threading</code>模块来创建和管理线程。线程是程序中的执行单元，一个进程可以包含多个线程。线程之间共享进程的内存空间，因此可以方便地在多个线程之间共享数据。</p>
<p>线程的创建方式有两种，一种是继承<code>threading.Thread</code>类并重写<code>run()</code>方法，另一种是传递一个可调用对象给<code>threading.Thread</code>构造函数。以下是一个使用第一种方式创建线程的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 线程要执行的代码</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线程对象并启动</span></span><br><span class="line">t = MyThread()</span><br><span class="line">t.start()</span><br></pre></td></tr></table></figure>

<h3 id="2-进程"><a href="#2-进程" class="headerlink" title="2. 进程"></a>2. 进程</h3><p>与线程类似，进程也是程序中的执行单元。每个进程都有自己独立的内存空间，因此不同进程之间不能直接共享数据。在Python中，我们可以使用<code>multiprocessing</code>模块来创建和管理进程。</p>
<p>进程的创建方式与线程类似，可以继承<code>multiprocessing.Process</code>类并重写<code>run()</code>方法，也可以传递一个可调用对象给<code>multiprocessing.Process</code>构造函数。以下是一个使用第一种方式创建进程的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyProcess</span>(multiprocessing.Process):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 进程要执行的代码</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建进程对象并启动</span></span><br><span class="line">p = MyProcess()</span><br><span class="line">p.start()</span><br></pre></td></tr></table></figure>

<h3 id="3-协程"><a href="#3-协程" class="headerlink" title="3. 协程"></a>3. 协程</h3><p>协程是一种轻量级的线程，它不是由操作系统内核来调度的，而是由程序员在代码中自行调度。在Python中，我们可以使用<code>asyncio</code>模块来创建和管理协程。</p>
<p>协程的创建方式是通过<code>async</code>关键字定义一个异步函数，函数内部可以使用<code>await</code>关键字来挂起当前协程。以下是一个使用<code>async</code>定义协程的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">my_coroutine</span>():</span><br><span class="line">    <span class="comment"># 协程要执行的代码</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>) <span class="comment"># 挂起当前协程1秒钟</span></span><br></pre></td></tr></table></figure>

<p>在协程中，我们通常会使用<code>async with</code>和<code>async for</code>等语法来管理资源和迭代器。</p>
<h3 id="4-线程、进程和协程的对比"><a href="#4-线程、进程和协程的对比" class="headerlink" title="4. 线程、进程和协程的对比"></a>4. 线程、进程和协程的对比</h3><p>线程、进程和协程都是用于实现并发编程的工具，但它们之间有一些区别。</p>
<p>线程和进程都是由操作系统内核来调度的，它们之间的切换需要进行上下文切换，会消耗一定的时间和资源。协程则是由程序自身调度，不需要进行上下文切换，因此可以更快地切换和调度，效率更高。在实现并发编程时，协程常常比线程和进程更适合，因为它不需要线程和进程所需的额外开销。</p>
<p>此外，线程和进程是在操作系统层面上实现的，并且可以利用多核处理器的优势，但是会存在一些问题，比如线程安全、死锁等问题。协程则是在程序运行时实现的，可以利用单线程的优势，避免了线程和进程所带来的一些问题，但是也存在一些需要注意的问题，比如阻塞、CPU密集型任务等。</p>
<p>另外，需要注意的是，线程和进程的通信需要使用锁、信号量、队列等同步机制，而协程则可以通过生成器、异步IO等机制来实现协作式多任务。</p>
<h3 id="异步编程库-asyncio"><a href="#异步编程库-asyncio" class="headerlink" title="异步编程库 asyncio"></a>异步编程库 asyncio</h3><p>异步编程库 asyncio 异步编程库 asyncio 是 Python 3.4 引入的标准库，它提供了一组异步 I&#x2F;O 原语，可以用于编写高效的并发代码。相较于多线程或多进程编程模型，异步编程模型可以更加高效地利用 CPU 和 I&#x2F;O 资源，因为它避免了线程或进程之间的切换开销。</p>
<p>异步编程模型中的核心概念是协程（coroutine），它是一种轻量级的线程，可以在同一个线程中并发执行，而不需要进行线程切换。在 Python 中，协程由 async&#x2F;await 关键字来实现。</p>
<p>在 asyncio 中，所有的 I&#x2F;O 操作都是异步的，这意味着我们可以在同一个线程中同时处理多个 I&#x2F;O 事件。asyncio 使用事件循环（event loop）来管理和调度协程。事件循环会在程序中不断地循环运行，等待并处理 I&#x2F;O 事件，当有事件发生时，它会将事件发送给相应的协程进行处理，协程执行完毕后，事件循环会重新调度下一个协程。</p>
<p>asyncio 提供了很多工具和方法，例如 Task、Future、Queue 等，用于管理协程的执行，这些工具和方法可以帮助我们更加方便地编写异步程序。</p>
<p>总之，异步编程库 asyncio 可以帮助我们在 Python 中编写高效的并发代码，使用协程实现异步编程，避免线程和进程切换的开销，提高程序的性能和响应速度。</p>
<p>以上就是 Python 的三个主要的并发编程库，它们分别是 threading、multiprocessing、asyncio。了解它们的特点和使用方法，可以帮助我们更好地理解并发编程，提高程序的性能和可维护性。</p>
<h2 id="多进程：multiprocessing"><a href="#多进程：multiprocessing" class="headerlink" title="多进程：multiprocessing"></a>多进程：multiprocessing</h2><h3 id="概念介绍："><a href="#概念介绍：" class="headerlink" title="概念介绍："></a>概念介绍：</h3><ol>
<li><code>Process</code> 类</li>
</ol>
<p><code>Process</code> 类是 <code>multiprocessing</code> 模块中最重要的类之一，用于创建新的进程。创建 <code>Process</code> 对象需要传入一个可调用对象（如函数）作为参数，该可调用对象会在新进程中执行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = multiprocessing.Process(target=func)</span><br><span class="line">    p.start()</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们定义了一个函数 <code>func()</code>，并创建了一个 <code>Process</code> 对象 <code>p</code>，将 <code>func()</code> 函数作为参数传入 <code>p</code> 中。在 <code>main</code> 函数中，我们调用 <code>start()</code> 方法来启动新的进程。这将在新的进程中执行 <code>func()</code> 函数。</p>
<ol>
<li>进程间通信</li>
</ol>
<p>由于每个进程都有自己的内存空间，因此多个进程之间无法直接共享数据。为了实现进程间的通信，<code>multiprocessing</code> 模块提供了多种通信机制，包括：</p>
<ul>
<li><code>Pipe</code> 管道：用于在两个进程之间传递数据。</li>
<li><code>Queue</code> 队列：用于在多个进程之间共享数据。</li>
<li><code>Value</code>：用于在多个进程之间共享一个数值。</li>
<li><code>Array</code>：用于在多个进程之间共享一个数组。</li>
</ul>
<p>下面以 <code>Queue</code> 为例，演示多进程之间的通信：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子进程执行的函数，参数为一个 Queue 对象</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = q.get()  <span class="comment"># 从队列中获取数据，如果队列为空，会一直阻塞直到有数据</span></span><br><span class="line">        <span class="keyword">if</span> data <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 如果获取到的数据为 None，则表示队列已经为空，子进程可以退出了</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Processing <span class="subst">&#123;data&#125;</span>&quot;</span>)  <span class="comment"># 处理获取到的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主进程</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    q = mp.Queue()  <span class="comment"># 创建一个进程安全的 Queue 对象</span></span><br><span class="line">    p1 = mp.Process(target=consumer, args=(q,))  <span class="comment"># 创建子进程 p1，将 Queue 对象作为参数传递给它</span></span><br><span class="line">    p2 = mp.Process(target=consumer, args=(q,))  <span class="comment"># 创建子进程 p2，将 Queue 对象作为参数传递给它</span></span><br><span class="line">    p1.start()  <span class="comment"># 启动子进程 p1</span></span><br><span class="line">    p2.start()  <span class="comment"># 启动子进程 p2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 向 Queue 对象中放入数据</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        q.put(i)</span><br><span class="line">    <span class="comment"># 向 Queue 对象中放入两个 None 值，用于告知子进程停止执行，# 放两个None值主要是因为有2个进程，如果只有一个则会有一个进程无法判定退出了</span></span><br><span class="line">    q.put(<span class="literal">None</span>)</span><br><span class="line">    q.put(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待子进程执行完成</span></span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们首先创建了一个 <code>Queue</code> 对象 <code>q</code>，然后创建了两个进程 <code>p1</code> 和 <code>p2</code>，并将 <code>q</code> 对象作为参数传递给它们。在主进程中，我们往 <code>q</code> 中放入了 10 个数据，并在最后放入两个 <code>None</code> 值，用于告知子进程停止执行。在子进程中，我们使用 <code>q.get()</code> 方法从 <code>q</code> 中读取数据，在子进程中，我们使用一个 while 循环不断地从队列中取出数据，并将其输出。当从队列中取出的数据为 None 时，表示主进程已经没有数据要放入队列中，此时子进程会结束循环，退出进程。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><strong>需要注意的是</strong>，多进程编程也有一些限制和注意事项。由于每个进程都拥有自己的内存空间，因此在进程间共享数据需要使用一些特殊的机制，如共享内存、队列、管道等。此外，由于创建和销毁进程的开销较大，因此在使用多进程编程时，需要注意进程的数量，避免过多的进程导致系统负载过重。</p>
<p>除了上述介绍的 <code>Process</code> 类，Python 多进程模块中还有一些常用的函数和类：</p>
<ol>
<li><code>multiprocessing.Queue</code>: 多进程队列，用于进程之间的通信，实现生产者消费者模型等。</li>
<li><code>multiprocessing.Pipe</code>: 多进程管道，与多进程队列类似，也是用于进程之间的通信，可以实现父子进程之间的通信。</li>
<li><code>multiprocessing.Manager</code>: 进程间共享数据，包括字典、列表、集合等，多进程模块中没有提供原生的线程安全的共享数据结构，需要使用该类实现。</li>
<li><code>multiprocessing.Pool</code>: 进程池，用于复用进程，节省进程创建销毁的开销，通常用于批量处理任务。</li>
</ol>
<p>除此之外，Python 多进程模块还提供了一些辅助函数和类，例如 <code>current_process</code>、<code>cpu_count</code>、<code>Value</code>、<code>Lock</code> 等，可以方便地获取当前进程、获取 CPU 核心数量、定义进程间共享变量、实现进程间同步等。</p>
<p>使用多进程模块的时候需要注意，由于多进程模块需要对进程进行复制和调度，所以它的资源占用和开销要比多线程模块要高。同时，由于进程之间的内存是隔离的，所以需要使用多进程队列、多进程管道等方式来实现进程间通信，而不能像多线程模块那样直接共享内存。另外，使用多进程模块时还需要注意，对于不支持 pickle 序列化的对象，需要自定义 <code>__reduce__</code> 方法来实现序列化，否则会报错。</p>
<h3 id="实例讲解"><a href="#实例讲解" class="headerlink" title="实例讲解"></a>实例讲解</h3><h4 id="模板示例："><a href="#模板示例：" class="headerlink" title="模板示例："></a>模板示例：</h4><p>多进程下载例子：（用线程池限制一次的线程数量）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_file</span>(<span class="params">url, filename</span>):</span><br><span class="line">    r = requests.get(url, stream=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> r.iter_content(chunk_size=<span class="number">1024</span>):</span><br><span class="line">            <span class="keyword">if</span> chunk:</span><br><span class="line">                f.write(chunk)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    urls = [<span class="string">&#x27;https://www.python.org/static/community_logos/python-logo-master-v3-TM.png&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;https://upload.wikimedia.org/wikipedia/commons/3/3c/OpenCV_Logo_with_text.png&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;https://www.scipy.org/_static/logo.png&#x27;</span>] * <span class="number">10000</span>  <span class="comment"># 重复 3 个链接 10000 次，总共 30000 个链接</span></span><br><span class="line">    filenames = [<span class="string">&#x27;python.png&#x27;</span>, <span class="string">&#x27;opencv.png&#x27;</span>, <span class="string">&#x27;scipy.png&#x27;</span>] * <span class="number">10000</span>  <span class="comment"># 重复 3 个文件名 10000 次，总共 30000 个文件名</span></span><br><span class="line">    chunk_size = <span class="number">100</span>  <span class="comment"># 每个块包含 100 个链接</span></span><br><span class="line">    chunks = [(urls[i:i+chunk_size], filenames[i:i+chunk_size]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(urls), chunk_size)]</span><br><span class="line">    pool = mp.Pool(processes=<span class="number">4</span>)  <span class="comment"># 最多同时运行 4 个进程</span></span><br><span class="line">    <span class="keyword">for</span> chunk_urls, chunk_filenames <span class="keyword">in</span> chunks:</span><br><span class="line">        pool.starmap_async(download_file, <span class="built_in">zip</span>(chunk_urls, chunk_filenames))</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这段代码的作用是使用 Python 的 multiprocessing 模块创建一个具有 4 个进程的进程池，并将任务拆分成多个小块进行并行处理。具体解释如下：</p>
<ul>
<li><code>mp.Pool(processes=4)</code>：创建一个具有 4 个进程的进程池，<code>processes</code> 参数指定最大进程数。</li>
<li><code>for chunk_urls, chunk_filenames in chunks:</code>：循环遍历拆分后的任务块。</li>
<li><code>pool.starmap_async(download_file, zip(chunk_urls, chunk_filenames))</code>：使用 <code>starmap_async()</code> 方法，将任务拆分成多个小块，每个小块分配到不同的进程上进行处理。<code>download_file</code> 函数会被异步调用，并且将 <code>zip(chunk_urls, chunk_filenames)</code> 作为参数传递给 <code>download_file</code> 函数。<code>starmap_async()</code> 方法会立即返回一个 AsyncResult 对象，不会等待所有进程执行完毕。</li>
<li><code>pool.close()</code>：关闭进程池，不再接受新的任务请求。</li>
<li><code>pool.join()</code>：等待进程池中所有进程执行完毕，并回收资源。</li>
</ul>
<p>总的来说，这段代码实现了并行处理多个任务，提高了程序的执行效率。因为一些任务之间可能存在依赖关系，所以 <code>starmap_async()</code> 方法比较适合处理彼此独立的任务。如果任务之间存在依赖关系，可以考虑使用 <code>map()</code> 方法，它是一种同步方式，会等待所有进程执行完毕后再返回结果。</p>
</blockquote>
<p>当任务之间存在依赖关系时，可以使用 <code>map()</code> 方法进行同步处理。以下是一个使用 <code>map()</code> 方法的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_input</span>(<span class="params">input_data</span>):</span><br><span class="line">    <span class="comment"># 处理输入数据</span></span><br><span class="line">    processed_data = input_data * <span class="number">2</span></span><br><span class="line">    <span class="comment"># 返回处理后的结果</span></span><br><span class="line">    <span class="keyword">return</span> processed_data</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    input_data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">    <span class="keyword">with</span> mp.Pool(processes=<span class="number">4</span>) <span class="keyword">as</span> pool:</span><br><span class="line">        <span class="comment"># 使用 map() 方法，将任务拆分成多个小块，每个小块分配到不同的进程上进行处理</span></span><br><span class="line">        result = pool.<span class="built_in">map</span>(process_input, input_data)</span><br><span class="line">    <span class="comment"># 输出处理结果</span></span><br><span class="line">    <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们定义了 <code>process_input()</code> 函数来处理输入的数据，这个函数只接受一个参数，并返回处理后的结果。在主函数中，我们使用 <code>Pool()</code> 创建了一个具有 4 个进程的进程池。然后，我们将输入数据 <code>input_data</code> 通过 <code>map()</code> 方法拆分成多个小块，每个小块分配到不同的进程上进行处理，并使用 <code>result</code> 变量来保存处理结果。</p>
<p>因为使用的是同步方式，所以程序会等待所有进程结束后再返回结果。最后，我们输出处理后的结果。</p>
<p>这个例子中，虽然使用了 <code>map()</code> 方法进行同步处理，但这些任务并没有明显的依赖关系，所以这种方法并没有发挥出它真正的优势。</p>
<h4 id="实战示例"><a href="#实战示例" class="headerlink" title="实战示例"></a>实战示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> wget</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取下载URL地址列表</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_down_urls</span>(<span class="params">file</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file) <span class="keyword">as</span> f:</span><br><span class="line">        urls = [x.strip() <span class="keyword">for</span> x <span class="keyword">in</span> f.readlines()]</span><br><span class="line">    <span class="keyword">return</span> urls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载单个文件的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_url</span>(<span class="params">url, filepath</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment">#获取当前进程信息,进程ID和进程名称</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;当前进程：<span class="subst">&#123;os.getpid()&#125;</span>,<span class="subst">&#123;multiprocessing.current_process().name&#125;</span>在下载<span class="subst">&#123;filepath&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="comment"># 下载文件</span></span><br><span class="line">        wget.download(url, out=filepath)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;下载完成<span class="subst">&#123;filepath&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="comment"># 输出异常信息</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;url&#125;</span> download failed: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主函数</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 读取下载地址列表</span></span><br><span class="line">    down_urls = get_down_urls(<span class="string">&quot;downurl.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自动创建下载目录</span></span><br><span class="line">    os.makedirs(<span class="string">&quot;./download&quot;</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动多进程下载</span></span><br><span class="line">    max_workers = <span class="number">5</span></span><br><span class="line">    pool = multiprocessing.Pool(processes=max_workers)</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> down_urls:</span><br><span class="line">        <span class="comment"># print(url)</span></span><br><span class="line">        pool.starmap_async(download_url,[(url,<span class="string">f&#x27;./download/<span class="subst">&#123;url.strip(<span class="string">&quot;https://home-store-img.uniontech.com/apppkg/&quot;</span>)&#125;</span>&#x27;</span>),])  <span class="comment">#核心内容就是这一句，能够自动按照上面设定的最大进程数来处理进程</span></span><br><span class="line"></span><br><span class="line">    pool.close() <span class="comment">#关闭进程池，不再接受新的任务请求。</span></span><br><span class="line">    pool.join() <span class="comment">#等待进程池中所有进程执行完毕，并回收资源。</span></span><br><span class="line">    <span class="comment"># 输出完成信息</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Download finished!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>输出内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">/usr/<span class="built_in">bin</span>/python3<span class="number">.7</span> /home/babyfengfjx/Documents/typora_documents/scripts/multi_processing/multi_process01.py </span><br><span class="line">当前进程：<span class="number">103240</span>,ForkPoolWorker-<span class="number">1</span>在下载./download/3660ab759c4949b4b0bc7439788d6cf4.deb</span><br><span class="line">当前进程：<span class="number">103241</span>,ForkPoolWorker-<span class="number">2</span>在下载./download/f4ca72cebdb64ef08a66d654ccd75fe7.deb</span><br><span class="line">当前进程：<span class="number">103242</span>,ForkPoolWorker-<span class="number">3</span>在下载./download/0fefdf796f4d430cb9382239575fb470.deb</span><br><span class="line">当前进程：<span class="number">103243</span>,ForkPoolWorker-<span class="number">4</span>在下载./download/967a987cf0bc4b599e6bb224aebb733c.deb</span><br><span class="line">当前进程：<span class="number">103244</span>,ForkPoolWorker-<span class="number">5</span>在下载./download/35fe5a660b034108a0f0d05b0188f341.deb</span><br><span class="line">下载完成./download/35fe5a660b034108a0f0d05b0188f341.deb</span><br><span class="line">当前进程：<span class="number">103244</span>,ForkPoolWorker-<span class="number">5</span>在下载./download/073d6369-7c92-4af9-ae34-a1b8f3074532</span><br><span class="line">下载完成./download/073d6369-7c92-4af9-ae34-a1b8f3074532</span><br><span class="line">当前进程：<span class="number">103244</span>,ForkPoolWorker-<span class="number">5</span>在下载./download/1af31599-78a0-4de0-<span class="number">8708</span>-828e6484619f</span><br><span class="line">下载完成./download/3660ab759c4949b4b0bc7439788d6cf4.deb</span><br><span class="line">当前进程：<span class="number">103240</span>,ForkPoolWorker-<span class="number">1</span>在下载./download/5be6d88a4b94862b17387152542c03d.deb</span><br><span class="line">下载完成./download/f4ca72cebdb64ef08a66d654ccd75fe7.deb</span><br><span class="line">当前进程：<span class="number">103241</span>,ForkPoolWorker-<span class="number">2</span>在下载./download/31c52d38c08248c4b7051d08005ba4c7.deb</span><br><span class="line">下载完成./download/31c52d38c08248c4b7051d08005ba4c7.deb</span><br><span class="line">当前进程：<span class="number">103241</span>,ForkPoolWorker-<span class="number">2</span>在下载./download/085a6bc5d3104b909e844aab64ee14ce.deb</span><br><span class="line">下载完成./download/085a6bc5d3104b909e844aab64ee14ce.deb</span><br><span class="line">当前进程：<span class="number">103241</span>,ForkPoolWorker-<span class="number">2</span>在下载./download/6280dfad416c4c99a6e6ccf5fe2efa84.deb</span><br><span class="line">下载完成./download/1af31599-78a0-4de0-<span class="number">8708</span>-828e6484619f</span><br><span class="line">当前进程：<span class="number">103244</span>,ForkPoolWorker-<span class="number">5</span>在下载./download/d632387490f4d70a346b3583922a2e4.deb</span><br></pre></td></tr></table></figure>

<h3 id="补充讲解"><a href="#补充讲解" class="headerlink" title="补充讲解"></a>补充讲解</h3><h4 id="pool-starmap-async-和-pool-map的区别："><a href="#pool-starmap-async-和-pool-map的区别：" class="headerlink" title="pool.starmap_async 和 pool.map的区别："></a>pool.starmap_async 和 pool.map的区别：</h4><ul>
<li><p><code>pool.starmap_async()</code> 和 <code>pool.map()</code> 都是进程池的方法，用于并行处理多个任务。它们的区别在于返回结果的方式和异步处理的方式。</p>
</li>
<li><p><code>pool.map()</code> 使用同步的方式处理多个任务，它将每个任务拆分成多个小块进行并行处理，然后等待所有进程执行完毕，并将处理后的结果返回到主进程。这个方法的返回结果是一个列表，列表中的每个元素对应一个任务的处理结果。<code>pool.map()</code> <strong>会按照任务在输入序列中出现的顺序返回任务的处理结果。</strong></p>
</li>
<li><p>而<code>pool.starmap_async()</code> 则是使用异步的方式处理多个任务，它也将每个任务拆分成多个小块进行并行处理，但不像 <code>pool.map()</code> 那样等待所有进程执行完毕后返回结果。<code>pool.starmap_async()</code> 会立即返回 <code>AsyncResult</code> 对象，<strong>不会阻塞程序继续运行</strong>。可以通过调用 <strong><code>AsyncResult.get()</code> 方法获得所有任务的处理结果</strong>，这个方法会阻塞程序并等待所有进程执行完毕后返回结果。这个方法的返回结果<strong>也是一个列表</strong>，列表中的每个元素对应一个任务的处理结果。但是这个返回的结果不是按照任务在输入序列中出现的顺序进行排序的。</p>
</li>
<li><p>所以，<code>pool.map()</code> 是同步的方法，会等待所有任务执行完毕后返回结果，而 <code>pool.starmap_async()</code> 是异步的方法，会立即返回一个 <code>AsyncResult</code> 对象，并不会等待任务执行完毕。**<code>pool.starmap_async()</code> 可能更适合处理运行时间较长的任务，而 <code>pool.map()</code> 更适合处理运行时间较短的任务。**</p>
</li>
</ul>
<h4 id="并发下载例子"><a href="#并发下载例子" class="headerlink" title="并发下载例子"></a>并发下载例子</h4><blockquote>
<p>需要编写一个多线程程序，同时下载这1000个应用的下载链接</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">download_app</span>(<span class="params">semaphore, url</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> semaphore:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">                <span class="comment"># 在这里处理下载的文件</span></span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">download_urls = [<span class="string">&quot;http://www.example.com/app1&quot;</span>, <span class="string">&quot;http://www.example.com/app2&quot;</span>, ...]</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    max_concurrency = <span class="number">20</span></span><br><span class="line">    semaphore = asyncio.Semaphore(max_concurrency)</span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> download_urls:</span><br><span class="line">        <span class="comment"># 提交下载任务给协程池</span></span><br><span class="line">        task = asyncio.ensure_future(download_app(semaphore, url))</span><br><span class="line">        tasks.append(task)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待所有任务完成</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这个示例中，我们定义了一个<code>Semaphore</code>实例，并将并发协程数量限制为20。然后在下载文件的协程函数<code>download_app</code>中，我们使用<code>async with semaphore</code>来控制同时运行的协程数量。</p>
<p>请注意，<code>Semaphore</code>只能用于限制并发协程数量，不能用于限制下载速度。如果您需要控制下载速度，可以考虑使用<code>asyncio.sleep</code>来添加延迟。</p>
</blockquote>
<p>当使用协程编程时，需要注意以下几点：</p>
<ol>
<li>理解协程的概念和异步编程的原理</li>
</ol>
<p>协程是一种轻量级线程，不需要操作系统进行线程切换，在用户空间内实现多任务调度。异步编程是基于协程实现的，通过利用I&#x2F;O等待时间，让CPU在等待期间处理其他任务，提高程序效率。理解协程和异步编程的原理是使用协程编程的前提。</p>
<ol>
<li>熟悉asyncio的用法</li>
</ol>
<p>asyncio是Python提供的异步IO框架，它提供了一套完整的异步编程解决方案，并且易于使用。使用asyncio可以轻松创建协程并管理它们的执行，从而实现高效的异步编程。</p>
<ol>
<li>避免阻塞操作</li>
</ol>
<p>在协程中使用阻塞操作会影响整个程序的性能，因为它会阻塞协程中其他任务的执行。所以，在协程中，应该尽量避免使用阻塞操作，例如同步I&#x2F;O操作，可以使用异步I&#x2F;O操作代替。</p>
<ol>
<li>理解协程的并发性质</li>
</ol>
<p>协程是并发执行的，但是需要注意协程间的调度顺序，以免出现死锁和竞争等问题。在编写协程代码时，需要根据具体情况考虑如何实现合理的协程调度，以达到预期的并发效果。</p>
<ol>
<li>注意协程的异常处理</li>
</ol>
<p>协程中可能会发生异常，如网络连接断开等，需要及时捕获并进行处理。在编写协程代码时，应该考虑如何处理异常情况，并采取适当的措施防止程序崩溃或出现其他不可预期的错误。</p>
<p>综上所述，使用协程编程需要综合考虑多个因素，包括协程的特性、异步编程的原理、asyncio的用法、阻塞操作的避免、并发调度的处理和异常处理等。只有掌握了这些要点，才能够编写出高效、稳定且可靠的协程程序。</p>
<h4 id="同步I-x2F-O操作和异步I-x2F-O操作"><a href="#同步I-x2F-O操作和异步I-x2F-O操作" class="headerlink" title="同步I&#x2F;O操作和异步I&#x2F;O操作"></a>同步I&#x2F;O操作和异步I&#x2F;O操作</h4><p>同步I&#x2F;O操作指的是程序执行一个I&#x2F;O操作时，必须等待这个操作完成（或者超时失败）才能继续执行后面的代码，也就是说程序会”阻塞”在这个I&#x2F;O操作上。而异步I&#x2F;O操作则是程序在执行I&#x2F;O操作时不会被“阻塞”，而是可以继续执行其他操作，等到I&#x2F;O操作完成后再进行相关后续处理。</p>
<p>下面是一个简单的例子，假设有个程序需要从磁盘读取文件内容并进行处理：</p>
<p>同步I&#x2F;O操作的实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;file.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read()  <span class="comment"># 需要等待文件读取完成才会继续执行后面的代码</span></span><br><span class="line">    <span class="comment"># 对文件data进行处理</span></span><br></pre></td></tr></table></figure>

<p>这里的<code>f.read()</code>是一个同步读取文件的操作，它会等待文件读取完成才会继续执行后面的代码。也就是说，当程序执行<code>f.read()</code>的时候，程序会被“阻塞”，无法执行其他的操作。</p>
<p>异步I&#x2F;O操作的实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_file</span>():</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;file.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = <span class="keyword">await</span> f.read()  <span class="comment"># 等待文件读取完成，但是不会阻塞程序执行</span></span><br><span class="line">        <span class="comment"># 对文件data进行处理，此时程序的执行不会被阻塞</span></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    data = <span class="keyword">await</span> read_file()</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(main())</span><br></pre></td></tr></table></figure>

<p>上面的代码中，我们使用了<code>asyncio</code>库实现了一个协程<code>read_file()</code>，它使用异步读取文件的方式，当执行到<code>await f.read()</code>时，程序会等待文件读取完成，但是不会阻塞程序执行，而是可以继续执行其他操作。这样，我们就可以在文件读取的同时，继续执行其他的操作，提高了程序的性能。</p>
<p>总之，同步I&#x2F;O操作会阻塞程序的执行，而异步I&#x2F;O操作可以不阻塞程序的执行，在等待I&#x2F;O操作完成的同时，可以继续执行其他操作，提高程序的效率。</p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/python/">python</a><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2023/03/08/33People%20powered/"><i class="fa fa-chevron-left">  </i><span>People powered 用户共创</span></a></div><div class="next-post pull-right"><a href="/2023/02/24/31python_dict/"><span>python中字典的基本用法</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'false' == 'true';
var verify = 'false' == 'true';
var record_ip = 'false' == 'true';
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  recordIP:record_ip,
  appId:'F1Yvbj0NxwrB3DRaljWZOPe9-gzGzoHsz',
  appKey:'vvI8fXV2CIAJXrex6pBlFHBz',
  placeholder:'留下您的评论建议吧~',
  avatar:'wavatar',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
})</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2023 By babyfengfjx</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script src="/js/search/algolia.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>